2025-05-31 17:23:29,039 - INFO - Starting test of 11 tasks: task_id_0, task_id_58, task_id_77, task_id_127, task_id_227, task_id_404, task_id_431, task_id_433, task_id_435, task_id_441, task_id_447
2025-05-31 17:23:29,040 - INFO - 
==================================================
2025-05-31 17:23:29,040 - INFO - Processing task task_id_0...
2025-05-31 17:23:29,040 - INFO - Reading problem description and code template from tasks/task_id_0...
2025-05-31 17:23:29,040 - INFO - Problem description length: 310 characters
2025-05-31 17:23:29,040 - INFO - Reading unit tests from tasks/task_id_0...
2025-05-31 17:23:29,040 - INFO - Unit tests length: 69 characters
2025-05-31 17:23:29,040 - INFO - Running main workflow to generate solution...
2025-05-31 17:23:29,040 - INFO - Problem description: -----Description----- 
This task requires writing a Lean 4 function that takes a natural number as input and returns the same natural number as output.

-----Input-----
The input consists of one natural number:
x: An natural number.

-----Output-----
The output is a natural number which the value equals to x.
2025-05-31 17:23:29,040 - INFO - Task Lean code: import Mathlib
import Aesop

-- Implementation
def ident (x : Nat) : Nat :=
  -- << CODE START >>
  {{code}}
  -- << CODE END >>


def ident_spec (x : Nat) (result: Nat) : Prop :=
  -- << SPEC START >>
  result = x
  -- << SPEC END >>

theorem ident_spec_satisfied (x : Nat) :
  ident_spec x (ident x) := by
  -- << PROOF START >>
  unfold ident ident_spec
  {{proof}}
  -- << PROOF END >>

2025-05-31 17:23:45,056 - DEBUG - Request options: {'method': 'post', 'url': '/embeddings', 'files': None, 'post_parser': <function Embeddings.create.<locals>.parser at 0x7e1edd764540>, 'json_data': {'input': 'Inductive Types - Theorem Proving in Lean 4\nTheorem Proving in Lean 4\n1.\nIntroduction\n2.\nDependent Type Theory\n3.\nPropositions and Proofs\n4.\nQuantifiers and Equality\n5.\nTactics\n6.\nInteracting with Lean\n7.\nInductive Types\n8.\nInduction and Recursion\n9.\nStructures and Records\n10.\nType Classes\n11.\nThe Conversion Tactic Mode\n12.\nAxioms and Computation\nLight (default)\nRust\nCoal\nNavy\nAyu\nTheorem Proving in Lean 4\nInductive Types\nWe have seen that Lean\'s formal foundation includes basic types,\nProp, Type 0, Type 1, Type 2, ...\n, and allows for the formation of\ndependent function types,\n(x : α) → β\n. In the examples, we have\nalso made use of additional types like\nBool\n,\nNat\n, and\nInt\n,\nand type constructors, like\nList\n, and product,\n×\n. In fact, in\nLean\'s library, every concrete type other than the universes and every\ntype constructor other than dependent arrows is an instance of a general family of\ntype constructions known as\ninductive types\n. It is remarkable that\nit is possible to construct a substantial edifice of mathematics based\non nothing more than the type universes, dependent arrow types, and inductive\ntypes; everything else follows from those.\nIntuitively, an inductive type is built up from a specified list of\nconstructors. In Lean, the syntax for specifying such a type is as\nfollows:\ninductive Foo where\n  | constructor₁ : ... → Foo\n  | constructor₂ : ... → Foo\n  ...\n  | constructorₙ : ... → Foo\nThe intuition is that each constructor specifies a way of building new\nobjects of\nFoo\n, possibly from previously constructed values. The\ntype\nFoo\nconsists of nothing more than the objects that are\nconstructed in this way. The first character\n|\nin an inductive\ndeclaration is optional. We can also separate constructors using a\ncomma instead of\n|\n.\nWe will see below that the arguments of the constructors can include\nobjects of type\nFoo\n, subject to a certain "positivity" constraint,\nwhich guarantees that elements of\nFoo\nare built from the bottom\nup. Roughly speaking, each\n...\ncan be any arrow type constructed from\nFoo\nand previously defined types, in which\nFoo\nappears, if at\nall, only as the "target" of the dependent arrow type.\nWe will provide a number of examples of inductive types. We will also\nconsider slight generalizations of the scheme above, to mutually\ndefined inductive types, and so-called\ninductive families\n.\nAs with the logical connectives, every inductive type comes with\nintroduction rules, which show how to construct an element of the\ntype, and elimination rules, which show how to "use" an element of the\ntype in another construction. The analogy to the logical connectives\nshould not come as a surprise; as we will see below, they, too, are\nexamples of inductive type constructions. You have already seen the\nintroduction rules for an inductive type: they are just the\nconstructors that are specified in the definition of the type. The\nelimination rules provide for a principle of recursion on the type,\nwhich includes, as a special case, a principle of induction as well.\nIn the next chapter, we will describe Lean\'s function definition\npackage, which provides even more convenient ways to define functions\non inductive types and carry out inductive proofs. But because the\nnotion of an inductive type is so fundamental, we feel it is important\nto start with a low-level, hands-on understanding. We will start with\nsome basic examples of inductive types, and work our way up to more\nelaborate and complex examples.\nEnumerated Types\nThe simplest kind of inductive type is a type with a finite, enumerated list of elements.\ninductive Weekday where\n  | sunday : Weekday\n  | monday : Weekday\n  | tuesday : Weekday\n  | wednesday : Weekday\n  | thursday : Weekday\n  | friday : Weekday\n  | saturday : Weekday\nThe\ninductive\ncommand creates a new type,\nWeekday\n. The\nconstructors all live in the\nWeekday\nnamespace.\ninductive Weekday where\n| sunday : Weekday\n| monday : Weekday\n| tuesday : Weekday\n| wednesday : Weekday\n| thursday : Weekday\n| friday : Weekday\n| saturday : Weekday\n#check Weekday.sunday\n#check Weekday.monday\n\nopen Weekday\n\n#check sunday\n#check monday\nYou can omit\n: Weekday\nwhen declaring the\nWeekday\ninductive type.\ninductive Weekday where\n  | sunday\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\nThink of\nsunday\n,\nmonday\n, ... ,\nsaturday\nas\nbeing distinct elements of\nWeekday\n, with no other distinguishing\nproperties. The elimination principle,\nWeekday.rec\n, is defined\nalong with the type\nWeekday\nand its constructors. It is also known\nas a\nrecursor\n, and it is what makes the type "inductive": it allows\nus to define a function on\nWeekday\nby assigning values\ncorresponding to each constructor. The intuition is that an inductive\ntype is exhaustively generated by the constructors, and has no\nelements beyond those they construct.\nWe will use the\nmatch\nexpression to define a function from\nWeekday\nto the natural numbers:\ninductive Weekday where\n| sunday : Weekday\n| monday : Weekday\n| tuesday : Weekday\n| wednesday : Weekday\n| thursday : Weekday\n| friday : Weekday\n| saturday : Weekday\nopen Weekday\n\ndef numberOfDay (d : Weekday) : Nat :=\n  match d with\n  | sunday    => 1\n  | monday    => 2\n  | tuesday   => 3\n  | wednesday => 4\n  | thursday  => 5\n  | friday    => 6\n  | saturday  => 7\n\n#eval numberOfDay Weekday.sunday  -- 1\n#eval numberOfDay Weekday.monday  -- 2\n#eval numberOfDay Weekday.tuesday -- 3\nNote that the\nmatch\nexpression is compiled using the\nrecursor\nWeekday.rec\ngenerated when\nyou declare the inductive type.\ninductive Weekday where\n| sunday : Weekday\n| monday : Weekday\n| tuesday : Weekday\n| wednesday : Weekday\n| thursday : Weekday\n| friday : Weekday\n| saturday : Weekday\nopen Weekday\n\ndef numberOfDay (d : Weekday) : Nat :=\n  match d with\n  | sunday    => 1\n  | monday    => 2\n  | tuesday   => 3\n  | wednesday => 4\n  | thursday  => 5\n  | friday    => 6\n  | saturday  => 7\n\nset_option pp.all true\n#print numberOfDay\n-- ... numberOfDay.match_1\n#print numberOfDay.match_1\n-- ... Weekday.casesOn ...\n#print Weekday.casesOn\n-- ... Weekday.rec ...\n#check @Weekday.rec\n/-\n@Weekday.rec.{u}\n : {motive : Weekday → Sort u} →\n    motive Weekday.sunday →\n    motive Weekday.monday →\n    motive Weekday.tuesday →\n    motive Weekday.wednesday →\n    motive Weekday.thursday →\n    motive Weekday.friday →\n    motive Weekday.saturday →\n    (t : Weekday) → motive t\n-/\nWhen declaring an inductive datatype, you can use\nderiving Repr\nto instruct\nLean to generate a function that converts\nWeekday\nobjects into text.\nThis function is used by the\n#eval\ncommand to display\nWeekday\nobjects.\ninductive Weekday where\n  | sunday\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  deriving Repr\n\nopen Weekday\n\n#eval tuesday   -- Weekday.tuesday\nIt is often useful to group definitions and theorems related to a\nstructure in a namespace with the same name. For example, we can put\nthe\nnumberOfDay\nfunction in the\nWeekday\nnamespace. We are\nthen allowed to use the shorter name when we open the namespace.\nWe can define functions from\nWeekday\nto\nWeekday\n:\ninductive Weekday where\n| sunday : Weekday\n| monday : Weekday\n| tuesday : Weekday\n| wednesday : Weekday\n| thursday : Weekday\n| friday : Weekday\n| saturday : Weekday\nderiving Repr\nnamespace Weekday\ndef next (d : Weekday) : Weekday :=\n  match d with\n  | sunday    => monday\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => saturday\n  | saturday  => sunday\n\ndef previous (d : Weekday) : Weekday :=\n  match d with\n  | sunday    => saturday\n  | monday    => sunday\n  | tuesday   => monday\n  | wednesday => tuesday\n  | thursday  => wednesday\n  | friday    => thursday\n  | saturday  => friday\n\n#eval next (next tuesday)      -- Weekday.thursday\n#eval next (previous tuesday)  -- Weekday.tuesday\n\nexample : next (previous tuesday) = tuesday :=\n  rfl\n\nend Weekday\nHow can we prove the general theorem that\nnext (previous d) = d\nfor any Weekday\nd\n? You can use\nmatch\nto provide a proof of the claim for each\nconstructor:\ninductive Weekday where\n| sunday : Weekday\n| monday : Weekday\n| tuesday : Weekday\n| wednesday : Weekday\n| thursday : Weekday\n| friday : Weekday\n| saturday : Weekday\nderiving Repr\nnamespace Weekday\ndef next (d : Weekday) : Weekday :=\nmatch d with\n| sunday    => monday\n| monday    => tuesday\n| tuesday   => wednesday\n| wednesday => thursday\n| thursday  => friday\n| friday    => saturday\n| saturday  => sunday\ndef previous (d : Weekday) : Weekday :=\nmatch d with\n| sunday    => saturday\n| monday    => sunday\n| tuesday   => monday\n| wednesday => tuesday\n| thursday  => wednesday\n| friday    => thursday\n| saturday  => friday\ndef next_previous (d : Weekday) : next (previous d) = d :=\n  match d with\n  | sunday    => rfl\n  | monday    => rfl\n  | tuesday   => rfl\n  | wednesday => rfl\n  | thursday  => rfl\n  | friday    => rfl\n  | saturday  => rfl\nUsing a tactic proof, we can be even more concise:\ninductive Weekday where\n| sunday : Weekday\n| monday : Weekday\n| tuesday : Weekday\n| wednesday : Weekday\n| thursday : Weekday\n| friday : Weekday\n| saturday : Weekday\nderiving Repr\nnamespace Weekday\ndef next (d : Weekday) : Weekday :=\nmatch d with\n| sunday    => monday\n| monday    => tuesday\n| tuesday   => wednesday\n| wednesday => thursday\n| thursday  => friday\n| friday    => saturday\n| saturday  => sunday\ndef previous (d : Weekday) : Weekday :=\nmatch d with\n| sunday    => saturday\n| monday    => sunday\n| tuesday   => monday\n| wednesday => tuesday\n| thursday  => wednesday\n| friday    => thursday\n| saturday  => friday\ndef next_previous (d : Weekday) : next (previous d) = d := by\n  cases d <;> rfl\nTactics for Inductive Types\nbelow will introduce additional\ntactics that are specifically designed to make use of inductive types.\nNotice that, under the propositions-as-types correspondence, we can\nuse\nmatch\nto prove theorems as well as define functions.  In other\nwords, under the propositions-as-types correspondence, the proof by\ncases is a kind of definition by cases, where what is being "defined"\nis a proof instead of a piece of data.\nThe\nBool\ntype in the Lean library is an instance of\nenumerated type.\nnamespace Hidden\ninductive Bool where\n  | false : Bool\n  | true  : Bool\nend Hidden\n(To run these examples, we put them in a namespace called\nHidden\n,\nso that a name like\nBool\ndoes not conflict with the\nBool\nin\nthe standard library. This is necessary because these types are part\nof the Lean "prelude" that is automatically imported when the system\nis started.)\nAs an exercise, you should think about what the introduction and\nelimination rules for these types do. As a further exercise, we\nsuggest defining boolean operations\nand\n,\nor\n,\nnot\non the\nBool\ntype, and verifying common identities. Note that you can define a\nbinary operation like\nand\nusing\nmatch\n:\nnamespace Hidden\ndef and (a b : Bool) : Bool :=\n  match a with\n  | true  => b\n  | false => false\nend Hidden\nSimilarly, most identities can be proved by introducing suitable\nmatch\n, and then using\nrfl\n.\nConstructors with Arguments\nEnumerated types are a very special case of inductive types, in which\nthe constructors take no arguments at all. In general, a\n"construction" can depend on data, which is then represented in the\nconstructed argument. Consider the definitions of the product type and\nsum type in the library:\nnamespace Hidden\ninductive Prod (α : Type u) (β : Type v)\n  | mk : α → β → Prod α β\n\ninductive Sum (α : Type u) (β : Type v) where\n  | inl : α → Sum α β\n  | inr : β → Sum α β\nend Hidden\nConsider what is going on in these examples.\nThe product type has one constructor,\nProd.mk\n,\nwhich takes two arguments. To define a function on\nProd α β\n, we\ncan assume the input is of the form\nProd.mk a b\n, and we have to\nspecify the output, in terms of\na\nand\nb\n. We can use this to\ndefine the two projections for\nProd\n. Remember that the standard\nlibrary defines notation\nα × β\nfor\nProd α β\nand\n(a, b)\nfor\nProd.mk a b\n.\nnamespace Hidden\ninductive Prod (α : Type u) (β : Type v)\n| mk : α → β → Prod α β\ndef fst {α : Type u} {β : Type v} (p : Prod α β) : α :=\n  match p with\n  | Prod.mk a b => a\n\ndef snd {α : Type u} {β : Type v} (p : Prod α β) : β :=\n  match p with\n  | Prod.mk a b => b\nend Hidden\nThe function\nfst\ntakes a pair,\np\n. The\nmatch\ninterprets\np\nas a pair,\nProd.mk a b\n. Recall also from\nDependent Type Theory\nthat to give these definitions the greatest generality possible, we allow\nthe types\nα\nand\nβ\nto belong to any universe.\nHere is another example where we use the recursor\nProd.casesOn\ninstead\nof\nmatch\n.\ndef prod_example (p : Bool × Nat) : Nat :=\n  Prod.casesOn (motive := fun _ => Nat) p (fun b n => cond b (2 * n) (2 * n + 1))\n\n#eval prod_example (true, 3)\n#eval prod_example (false, 3)\nThe argument\nmotive\nis used to specify the type of the object you want to\nconstruct, and it is a function because it may depend on the pair.\nThe\ncond\nfunction is a boolean conditional:\ncond b t1 t2\nreturns\nt1\nif\nb\nis true, and\nt2\notherwise.\nThe function\nprod_example\ntakes a pair consisting of a boolean,\nb\n, and a number,\nn\n, and returns either\n2 * n\nor\n2 * n + 1\naccording to whether\nb\nis true or false.\nIn contrast, the sum type has\ntwo\nconstructors,\ninl\nand\ninr\n(for "insert left" and "insert right"), each of which takes\none\n(explicit) argument. To define a function on\nSum α β\n, we have to\nhandle two cases: either the input is of the form\ninl a\n, in which\ncase we have to specify an output value in terms of\na\n, or the\ninput is of the form\ninr b\n, in which case we have to specify an\noutput value in terms of\nb\n.\ndef sum_example (s : Sum Nat Nat) : Nat :=\n  Sum.casesOn (motive := fun _ => Nat) s\n    (fun n => 2 * n)\n    (fun n => 2 * n + 1)\n\n#eval sum_example (Sum.inl 3)\n#eval sum_example (Sum.inr 3)\nThis example is similar to the previous one, but now an input to\nsum_example\nis implicitly either of the form\ninl n\nor\ninr n\n.\nIn the first case, the function returns\n2 * n\n, and the second\ncase, it returns\n2 * n + 1\n.\nNotice that the product type depends on parameters\nα β : Type\nwhich are arguments to the constructors as well as\nProd\n. Lean\ndetects when these arguments can be inferred from later arguments to a\nconstructor or the return type, and makes them implicit in that case.\nIn\nSection Defining the Natural Numbers\nwe will see what happens when the\nconstructor of an inductive type takes arguments from the inductive\ntype itself. What characterizes the examples we consider in this\nsection is that each constructor relies only on previously specified types.\nNotice that a type with multiple constructors is disjunctive: an\nelement of\nSum α β\nis either of the form\ninl a\nor\nof the\nform\ninl b\n. A constructor with multiple arguments introduces\nconjunctive information: from an element\nProd.mk a b\nof\nProd α β\nwe can extract\na\nand\nb\n. An arbitrary inductive type can\ninclude both features, by having any number of constructors, each of\nwhich takes any number of arguments.\nAs with function definitions, Lean\'s inductive definition syntax will\nlet you put named arguments to the constructors before the colon:\nnamespace Hidden\ninductive Prod (α : Type u) (β : Type v) where\n  | mk (fst : α) (snd : β) : Prod α β\n\ninductive Sum (α : Type u) (β : Type v) where\n  | inl (a : α) : Sum α β\n  | inr (b : β) : Sum α β\nend Hidden\nThe results of these definitions are essentially the same as the ones given earlier in this section.\nA type, like\nProd\n, that has only one constructor is purely\nconjunctive: the constructor simply packs the list of arguments into a\nsingle piece of data, essentially a tuple where the type of subsequent\narguments can depend on the type of the initial argument. We can also\nthink of such a type as a "record" or a "structure". In Lean, the\nkeyword\nstructure\ncan be used to define such an inductive type as\nwell as its projections, at the same time.\nnamespace Hidden\nstructure Prod (α : Type u) (β : Type v) where\n  mk :: (fst : α) (snd : β)\nend Hidden\nThis example simultaneously introduces the inductive type,\nProd\n,\nits constructor,\nmk\n, the usual eliminators (\nrec\nand\nrecOn\n), as well as the projections,\nfst\nand\nsnd\n, as\ndefined above.\nIf you do not name the constructor, Lean uses\nmk\nas a default. For\nexample, the following defines a record to store a color as a triple\nof RGB values:\nstructure Color where\n  (red : Nat) (green : Nat) (blue : Nat)\n  deriving Repr\n\ndef yellow := Color.mk 255 255 0\n\n#eval Color.red yellow\nThe definition of\nyellow\nforms the record with the three values\nshown, and the projection\nColor.red\nreturns the red component.\nYou can avoid the parentheses if you add a line break between each field.\nstructure Color where\n  red : Nat\n  green : Nat\n  blue : Nat\n  deriving Repr\nThe\nstructure\ncommand is especially useful for defining algebraic\nstructures, and Lean provides substantial infrastructure to support\nworking with them. Here, for example, is the definition of a\nsemigroup:\nstructure Semigroup where\n  carrier : Type u\n  mul : carrier → carrier → carrier\n  mul_assoc : ∀ a b c, mul (mul a b) c = mul a (mul b c)\nWe will see more examples in\nChapter Structures and Records\n.\nWe have already discussed the dependent product type\nSigma\n:\nnamespace Hidden\ninductive Sigma {α : Type u} (β : α → Type v) where\n  | mk : (a : α) → β a → Sigma β\nend Hidden\nTwo more examples of inductive types in the library are the following:\nnamespace Hidden\ninductive Option (α : Type u) where\n  | none : Option α\n  | some : α → Option α\n\ninductive Inhabited (α : Type u) where\n  | mk : α → Inhabited α\nend Hidden\nIn the semantics of dependent type theory, there is no built-in notion\nof a partial function. Every element of a function type\nα → β\nor a\ndependent function type\n(a : α) → β\nis assumed to have a value\nat every input. The\nOption\ntype provides a way of representing partial functions. An\nelement of\nOption β\nis either\nnone\nor of the form\nsome b\n,\nfor some value\nb : β\n. Thus we can think of an element\nf\nof the\ntype\nα → Option β\nas being a partial function from\nα\nto\nβ\n:\nfor every\na : α\n,\nf a\neither returns\nnone\n, indicating\nf a\nis "undefined", or\nsome b\n.\nAn element of\nInhabited α\nis simply a witness to the fact that\nthere is an element of\nα\n. Later, we will see that\nInhabited\nis\nan example of a\ntype class\nin Lean: Lean can be instructed that\nsuitable base types are inhabited, and can automatically infer that\nother constructed types are inhabited on that basis.\nAs exercises, we encourage you to develop a notion of composition for\npartial functions from\nα\nto\nβ\nand\nβ\nto\nγ\n, and show\nthat it behaves as expected. We also encourage you to show that\nBool\nand\nNat\nare inhabited, that the product of two inhabited\ntypes is inhabited, and that the type of functions to an inhabited\ntype is inhabited.\nInductively Defined Propositions\nInductively defined types can live in any type universe, including the\nbottom-most one,\nProp\n. In fact, this is exactly how the logical\nconnectives are defined.\nnamespace Hidden\ninductive False : Prop\n\ninductive True : Prop where\n  | intro : True\n\ninductive And (a b : Prop) : Prop where\n  | intro : a → b → And a b\n\ninductive Or (a b : Prop) : Prop where\n  | inl : a → Or a b\n  | inr : b → Or a b\nend Hidden\nYou should think about how these give rise to the introduction and\nelimination rules that you have already seen. There are rules that\ngovern what the eliminator of an inductive type can eliminate\nto\n,\nthat is, what kinds of types can be the target of a recursor. Roughly\nspeaking, what characterizes inductive types in\nProp\nis that one\ncan only eliminate to other types in\nProp\n. This is consistent with\nthe understanding that if\np : Prop\n, an element\nhp : p\ncarries\nno data. There is a small exception to this rule, however, which we\nwill discuss below, in\nSection Inductive Families\n.\nEven the existential quantifier is inductively defined:\nnamespace Hidden\ninductive Exists {α : Sort u} (p : α → Prop) : Prop where\n  | intro (w : α) (h : p w) : Exists p\nend Hidden\nKeep in mind that the notation\n∃ x : α, p\nis syntactic sugar for\nExists (fun x : α => p)\n.\nThe definitions of\nFalse\n,\nTrue\n,\nAnd\n, and\nOr\nare\nperfectly analogous to the definitions of\nEmpty\n,\nUnit\n,\nProd\n, and\nSum\n. The difference is that the first group yields\nelements of\nProp\n, and the second yields elements of\nType u\nfor\nsome\nu\n. In a similar way,\n∃ x : α, p\nis a\nProp\n-valued\nvariant of\nΣ x : α, p\n.\nThis is a good place to mention another inductive type, denoted\n{x : α // p}\n, which is sort of a hybrid between\n∃ x : α, P\nand\nΣ x : α, P\n.\nnamespace Hidden\ninductive Subtype {α : Type u} (p : α → Prop) where\n  | mk : (x : α) → p x → Subtype p\nend Hidden\nIn fact, in Lean,\nSubtype\nis defined using the structure command:\nnamespace Hidden\nstructure Subtype {α : Sort u} (p : α → Prop) where\n  val : α\n  property : p val\nend Hidden\nThe notation\n{x : α // p x}\nis syntactic sugar for\nSubtype (fun x : α => p x)\n.\nIt is modeled after subset notation in set theory: the idea is that\n{x : α // p x}\ndenotes the collection of elements of\nα\nthat have property\np\n.\nDefining the Natural Numbers\nThe inductively defined types we have seen so far are "flat":\nconstructors wrap data and insert it into a type, and the\ncorresponding recursor unpacks the data and acts on it. Things get\nmuch more interesting when the constructors act on elements of the\nvery type being defined. A canonical example is the type\nNat\nof\nnatural numbers:\nnamespace Hidden\ninductive Nat where\n  | zero : Nat\n  | succ : Nat → Nat\nend Hidden\nThere are two constructors. We start with\nzero : Nat\n; it takes\nno arguments, so we have it from the start. In contrast, the\nconstructor\nsucc\ncan only be applied to a previously constructed\nNat\n. Applying it to\nzero\nyields\nsucc zero : Nat\n. Applying\nit again yields\nsucc (succ zero) : Nat\n, and so on. Intuitively,\nNat\nis the "smallest" type with these constructors, meaning that\nit is exhaustively (and freely) generated by starting with\nzero\nand applying\nsucc\nrepeatedly.\nAs before, the recursor for\nNat\nis designed to define a dependent\nfunction\nf\nfrom\nNat\nto any domain, that is, an element\nf\nof\n(n : Nat) → motive n\nfor some\nmotive : Nat → Sort u\n.\nIt has to handle two cases: the case where the input is\nzero\n, and the case where\nthe input is of the form\nsucc n\nfor some\nn : Nat\n. In the first\ncase, we simply specify a target value with the appropriate type, as\nbefore. In the second case, however, the recursor can assume that a\nvalue of\nf\nat\nn\nhas already been computed. As a result, the\nnext argument to the recursor specifies a value for\nf (succ n)\nin\nterms of\nn\nand\nf n\n. If we check the type of the recursor,\nnamespace Hidden\ninductive Nat where\n| zero : Nat\n| succ : Nat → Nat\n#check @Nat.rec\nend Hidden\nyou find the following:\n{motive : Nat → Sort u}\n  → motive Nat.zero\n  → ((n : Nat) → motive n → motive (Nat.succ n))\n  → (t : Nat) → motive t\nThe implicit argument,\nmotive\n, is the codomain of the function being defined.\nIn type theory it is common to say\nmotive\nis the\nmotive\nfor the elimination/recursion,\nsince it describes the kind of object we wish to construct.\nThe next two arguments specify how to compute the zero and successor cases, as described above.\nThey are also known as the\nminor premises\n.\nFinally, the\nt : Nat\n, is the input to the function. It is also known as the\nmajor premise\n.\nThe\nNat.recOn\nis similar to\nNat.rec\nbut the major premise occurs before the minor premises.\n@Nat.recOn :\n  {motive : Nat → Sort u}\n  → (t : Nat)\n  → motive Nat.zero\n  → ((n : Nat) → motive n → motive (Nat.succ n))\n  → motive t\nConsider, for example, the addition function\nadd m n\non the\nnatural numbers. Fixing\nm\n, we can define addition by recursion on\nn\n. In the base case, we set\nadd m zero\nto\nm\n. In the\nsuccessor step, assuming the value\nadd m n\nis already determined,\nwe define\nadd m (succ n)\nto be\nsucc (add m n)\n.\nnamespace Hidden\ninductive Nat where\n  | zero : Nat\n  | succ : Nat → Nat\n  deriving Repr\n\ndef add (m n : Nat) : Nat :=\n  match n with\n  | Nat.zero   => m\n  | Nat.succ n => Nat.succ (add m n)\n\nopen Nat\n\n#eval add (succ (succ zero)) (succ zero)\nend Hidden\nIt is useful to put such definitions into a namespace,\nNat\n. We can\nthen go on to define familiar notation in that namespace. The two\ndefining equations for addition now hold definitionally:\nnamespace Hidden\ninductive Nat where\n| zero : Nat\n| succ : Nat → Nat\nderiving Repr\nnamespace Nat\n\ndef add (m n : Nat) : Nat :=\n  match n with\n  | Nat.zero   => m\n  | Nat.succ n => Nat.succ (add m n)\n\ninstance : Add Nat where\n  add := add\n\ntheorem add_zero (m : Nat) : m + zero = m := rfl\ntheorem add_succ (m n : Nat) : m + succ n = succ (m + n) := rfl\n\nend Nat\nend Hidden\nWe will explain how the\ninstance\ncommand works in\nChapter Type Classes\n. In the examples below, we will use\nLean\'s version of the natural numbers.\nProving a fact like\nzero + m = m\n, however, requires a proof by induction.\nAs observed above, the induction principle is just a special case of the recursion principle,\nwhen the codomain\nmotive n\nis an element of\nProp\n. It represents the familiar\npattern of an inductive proof: to prove\n∀ n, motive n\n, first prove\nmotive 0\n,\nand then, for arbitrary\nn\n, assume\nih : motive n\nand prove\nmotive (succ n)\n.\nnamespace Hidden\nopen Nat\n\ntheorem zero_add (n : Nat) : 0 + n = n :=\n  Nat.recOn (motive := fun x => 0 + x = x)\n   n\n   (show 0 + 0 = 0 from rfl)\n   (fun (n : Nat) (ih : 0 + n = n) =>\n    show 0 + succ n = succ n from\n    calc 0 + succ n\n      _ = succ (0 + n) := rfl\n      _ = succ n       := by rw [ih])\nend Hidden\nNotice that, once again, when\nNat.recOn\nis used in the context of\na proof, it is really the induction principle in disguise. The\nrewrite\nand\nsimp\ntactics tend to be very effective in proofs\nlike these. In this case, each can be used to reduce the proof to:\nnamespace Hidden\nopen Nat\n\ntheorem zero_add (n : Nat) : 0 + n = n :=\n  Nat.recOn (motive := fun x => 0 + x = x) n\n    rfl\n    (fun n ih => by simp [add_succ, ih])\nend Hidden\nAs another example, let us prove the associativity of addition,\n∀ m n k, m + n + k = m + (n + k)\n.\n(The notation\n+\n, as we have defined it, associates to the left, so\nm + n + k\nis really\n(m + n) + k\n.)\nThe hardest part is figuring out which variable to do the induction on. Since addition is defined by recursion on the second argument,\nk\nis a good guess, and once we make that choice the proof almost writes itself:\nnamespace Hidden\nopen Nat\ntheorem add_assoc (m n k : Nat) : m + n + k = m + (n + k) :=\n  Nat.recOn (motive := fun k => m + n + k = m + (n + k)) k\n    (show m + n + 0 = m + (n + 0) from rfl)\n    (fun k (ih : m + n + k = m + (n + k)) =>\n      show m + n + succ k = m + (n + succ k) from\n      calc m + n + succ k\n        _ = succ (m + n + k)   := rfl\n        _ = succ (m + (n + k)) := by rw [ih]\n        _ = m + succ (n + k)   := rfl\n        _ = m + (n + succ k)   := rfl)\nend Hidden\nOnce again, you can reduce the proof to:\nopen Nat\ntheorem add_assoc (m n k : Nat) : m + n + k = m + (n + k) :=\n  Nat.recOn (motive := fun k => m + n + k = m + (n + k)) k\n    rfl\n    (fun k ih => by simp [Nat.add_succ, ih])\nSuppose we try to prove the commutativity of addition. Choosing induction on the second argument, we might begin as follows:\nopen Nat\ntheorem add_comm (m n : Nat) : m + n = n + m :=\n  Nat.recOn (motive := fun x => m + x = x + m) n\n   (show m + 0 = 0 + m by rw [Nat.zero_add, Nat.add_zero])\n   (fun (n : Nat) (ih : m + n = n + m) =>\n    show m + succ n = succ n + m from\n    calc m + succ n\n      _ = succ (m + n) := rfl\n      _ = succ (n + m) := by rw [ih]\n      _ = succ n + m   := sorry)\nAt this point, we see that we need another supporting fact, namely, that\nsucc (n + m) = succ n + m\n.\nYou can prove this by induction on\nm\n:\nopen Nat\n\ntheorem succ_add (n m : Nat) : succ n + m = succ (n + m) :=\n  Nat.recOn (motive := fun x => succ n + x = succ (n + x)) m\n    (show succ n + 0 = succ (n + 0) from rfl)\n    (fun (m : Nat) (ih : succ n + m = succ (n + m)) =>\n     show succ n + succ m = succ (n + succ m) from\n     calc succ n + succ m\n       _ = succ (succ n + m)   := rfl\n       _ = succ (succ (n + m)) := by rw [ih]\n       _ = succ (n + succ m)   := rfl)\nYou can then replace the\nsorry\nin the previous proof with\nsucc_add\n. Yet again, the proofs can be compressed:\nnamespace Hidden\nopen Nat\ntheorem succ_add (n m : Nat) : succ n + m = succ (n + m) :=\n  Nat.recOn (motive := fun x => succ n + x = succ (n + x)) m\n    rfl\n    (fun m ih => by simp only [add_succ, ih])\n\ntheorem add_comm (m n : Nat) : m + n = n + m :=\n  Nat.recOn (motive := fun x => m + x = x + m) n\n    (by simp)\n    (fun m ih', 'model': 'text-embedding-3-small', 'encoding_format': 'base64'}}
2025-05-31 17:23:45,059 - DEBUG - Sending HTTP Request: POST https://api.openai.com/v1/embeddings
2025-05-31 17:23:45,059 - DEBUG - connect_tcp.started host='api.openai.com' port=443 local_address=None timeout=5.0 socket_options=None
2025-05-31 17:23:45,066 - DEBUG - connect_tcp.complete return_value=<httpcore._backends.sync.SyncStream object at 0x7e1ee4d755b0>
2025-05-31 17:23:45,066 - DEBUG - start_tls.started ssl_context=<ssl.SSLContext object at 0x7e1ee51d2a50> server_hostname='api.openai.com' timeout=5.0
2025-05-31 17:23:45,076 - DEBUG - start_tls.complete return_value=<httpcore._backends.sync.SyncStream object at 0x7e1ee515b590>
2025-05-31 17:23:45,076 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-05-31 17:23:45,076 - DEBUG - send_request_headers.complete
2025-05-31 17:23:45,076 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-05-31 17:23:45,076 - DEBUG - send_request_body.complete
2025-05-31 17:23:45,076 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-05-31 17:23:45,839 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 429, b'Too Many Requests', [(b'Date', b'Sat, 31 May 2025 17:23:45 GMT'), (b'Content-Type', b'application/json; charset=utf-8'), (b'Content-Length', b'337'), (b'Connection', b'keep-alive'), (b'vary', b'Origin'), (b'x-request-id', b'req_015144ecc67c8c9a2ab9d2a32613d751'), (b'strict-transport-security', b'max-age=31536000; includeSubDomains; preload'), (b'cf-cache-status', b'DYNAMIC'), (b'Set-Cookie', b'__cf_bm=KGZm5t658LygRapnK07gEXW4glQICDpWesEJ6UC3nCg-1748712225-1.0.1.1-f.xiuB.JBzsk_xQMeM8RK5D4Fs4VD0Nx2RVViZyjEJra.SrcxbCVrVXk6gCFqq.c2e571ESc93wULcOL0nLGL1BeP_ZhwVqBmGLVnUQvl_s; path=/; expires=Sat, 31-May-25 17:53:45 GMT; domain=.api.openai.com; HttpOnly; Secure; SameSite=None'), (b'X-Content-Type-Options', b'nosniff'), (b'Set-Cookie', b'_cfuvid=uMmLSfBEUwAher7cYpWmWVehf9sH9mWcsEHCmX9cvdI-1748712225832-0.0.1.1-604800000; path=/; domain=.api.openai.com; HttpOnly; Secure; SameSite=None'), (b'Server', b'cloudflare'), (b'CF-RAY', b'9488292ebe543b10-BOM'), (b'alt-svc', b'h3=":443"; ma=86400')])
2025-05-31 17:23:45,840 - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 429 Too Many Requests"
2025-05-31 17:23:45,840 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-05-31 17:23:45,840 - DEBUG - receive_response_body.complete
2025-05-31 17:23:45,840 - DEBUG - response_closed.started
2025-05-31 17:23:45,840 - DEBUG - response_closed.complete
2025-05-31 17:23:45,840 - DEBUG - HTTP Response: POST https://api.openai.com/v1/embeddings "429 Too Many Requests" Headers([('date', 'Sat, 31 May 2025 17:23:45 GMT'), ('content-type', 'application/json; charset=utf-8'), ('content-length', '337'), ('connection', 'keep-alive'), ('vary', 'Origin'), ('x-request-id', 'req_015144ecc67c8c9a2ab9d2a32613d751'), ('strict-transport-security', 'max-age=31536000; includeSubDomains; preload'), ('cf-cache-status', 'DYNAMIC'), ('set-cookie', '__cf_bm=KGZm5t658LygRapnK07gEXW4glQICDpWesEJ6UC3nCg-1748712225-1.0.1.1-f.xiuB.JBzsk_xQMeM8RK5D4Fs4VD0Nx2RVViZyjEJra.SrcxbCVrVXk6gCFqq.c2e571ESc93wULcOL0nLGL1BeP_ZhwVqBmGLVnUQvl_s; path=/; expires=Sat, 31-May-25 17:53:45 GMT; domain=.api.openai.com; HttpOnly; Secure; SameSite=None'), ('x-content-type-options', 'nosniff'), ('set-cookie', '_cfuvid=uMmLSfBEUwAher7cYpWmWVehf9sH9mWcsEHCmX9cvdI-1748712225832-0.0.1.1-604800000; path=/; domain=.api.openai.com; HttpOnly; Secure; SameSite=None'), ('server', 'cloudflare'), ('cf-ray', '9488292ebe543b10-BOM'), ('alt-svc', 'h3=":443"; ma=86400')])
2025-05-31 17:23:45,840 - DEBUG - request_id: req_015144ecc67c8c9a2ab9d2a32613d751
2025-05-31 17:23:45,840 - DEBUG - Encountered httpx.HTTPStatusError
Traceback (most recent call last):
  File "/usr/local/lib/python3.12/dist-packages/openai/_base_client.py", line 1007, in _request
    response.raise_for_status()
  File "/usr/local/lib/python3.12/dist-packages/httpx/_models.py", line 829, in raise_for_status
    raise HTTPStatusError(message, request=request, response=self)
httpx.HTTPStatusError: Client error '429 Too Many Requests' for url 'https://api.openai.com/v1/embeddings'
For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429
2025-05-31 17:23:45,842 - DEBUG - Retrying due to status code 429
2025-05-31 17:23:45,842 - DEBUG - 2 retries left
2025-05-31 17:23:45,842 - INFO - Retrying request to /embeddings in 0.383352 seconds
2025-05-31 17:23:46,226 - DEBUG - Request options: {'method': 'post', 'url': '/embeddings', 'files': None, 'post_parser': <function Embeddings.create.<locals>.parser at 0x7e1edd764540>, 'json_data': {'input': 'Inductive Types - Theorem Proving in Lean 4\nTheorem Proving in Lean 4\n1.\nIntroduction\n2.\nDependent Type Theory\n3.\nPropositions and Proofs\n4.\nQuantifiers and Equality\n5.\nTactics\n6.\nInteracting with Lean\n7.\nInductive Types\n8.\nInduction and Recursion\n9.\nStructures and Records\n10.\nType Classes\n11.\nThe Conversion Tactic Mode\n12.\nAxioms and Computation\nLight (default)\nRust\nCoal\nNavy\nAyu\nTheorem Proving in Lean 4\nInductive Types\nWe have seen that Lean\'s formal foundation includes basic types,\nProp, Type 0, Type 1, Type 2, ...\n, and allows for the formation of\ndependent function types,\n(x : α) → β\n. In the examples, we have\nalso made use of additional types like\nBool\n,\nNat\n, and\nInt\n,\nand type constructors, like\nList\n, and product,\n×\n. In fact, in\nLean\'s library, every concrete type other than the universes and every\ntype constructor other than dependent arrows is an instance of a general family of\ntype constructions known as\ninductive types\n. It is remarkable that\nit is possible to construct a substantial edifice of mathematics based\non nothing more than the type universes, dependent arrow types, and inductive\ntypes; everything else follows from those.\nIntuitively, an inductive type is built up from a specified list of\nconstructors. In Lean, the syntax for specifying such a type is as\nfollows:\ninductive Foo where\n  | constructor₁ : ... → Foo\n  | constructor₂ : ... → Foo\n  ...\n  | constructorₙ : ... → Foo\nThe intuition is that each constructor specifies a way of building new\nobjects of\nFoo\n, possibly from previously constructed values. The\ntype\nFoo\nconsists of nothing more than the objects that are\nconstructed in this way. The first character\n|\nin an inductive\ndeclaration is optional. We can also separate constructors using a\ncomma instead of\n|\n.\nWe will see below that the arguments of the constructors can include\nobjects of type\nFoo\n, subject to a certain "positivity" constraint,\nwhich guarantees that elements of\nFoo\nare built from the bottom\nup. Roughly speaking, each\n...\ncan be any arrow type constructed from\nFoo\nand previously defined types, in which\nFoo\nappears, if at\nall, only as the "target" of the dependent arrow type.\nWe will provide a number of examples of inductive types. We will also\nconsider slight generalizations of the scheme above, to mutually\ndefined inductive types, and so-called\ninductive families\n.\nAs with the logical connectives, every inductive type comes with\nintroduction rules, which show how to construct an element of the\ntype, and elimination rules, which show how to "use" an element of the\ntype in another construction. The analogy to the logical connectives\nshould not come as a surprise; as we will see below, they, too, are\nexamples of inductive type constructions. You have already seen the\nintroduction rules for an inductive type: they are just the\nconstructors that are specified in the definition of the type. The\nelimination rules provide for a principle of recursion on the type,\nwhich includes, as a special case, a principle of induction as well.\nIn the next chapter, we will describe Lean\'s function definition\npackage, which provides even more convenient ways to define functions\non inductive types and carry out inductive proofs. But because the\nnotion of an inductive type is so fundamental, we feel it is important\nto start with a low-level, hands-on understanding. We will start with\nsome basic examples of inductive types, and work our way up to more\nelaborate and complex examples.\nEnumerated Types\nThe simplest kind of inductive type is a type with a finite, enumerated list of elements.\ninductive Weekday where\n  | sunday : Weekday\n  | monday : Weekday\n  | tuesday : Weekday\n  | wednesday : Weekday\n  | thursday : Weekday\n  | friday : Weekday\n  | saturday : Weekday\nThe\ninductive\ncommand creates a new type,\nWeekday\n. The\nconstructors all live in the\nWeekday\nnamespace.\ninductive Weekday where\n| sunday : Weekday\n| monday : Weekday\n| tuesday : Weekday\n| wednesday : Weekday\n| thursday : Weekday\n| friday : Weekday\n| saturday : Weekday\n#check Weekday.sunday\n#check Weekday.monday\n\nopen Weekday\n\n#check sunday\n#check monday\nYou can omit\n: Weekday\nwhen declaring the\nWeekday\ninductive type.\ninductive Weekday where\n  | sunday\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\nThink of\nsunday\n,\nmonday\n, ... ,\nsaturday\nas\nbeing distinct elements of\nWeekday\n, with no other distinguishing\nproperties. The elimination principle,\nWeekday.rec\n, is defined\nalong with the type\nWeekday\nand its constructors. It is also known\nas a\nrecursor\n, and it is what makes the type "inductive": it allows\nus to define a function on\nWeekday\nby assigning values\ncorresponding to each constructor. The intuition is that an inductive\ntype is exhaustively generated by the constructors, and has no\nelements beyond those they construct.\nWe will use the\nmatch\nexpression to define a function from\nWeekday\nto the natural numbers:\ninductive Weekday where\n| sunday : Weekday\n| monday : Weekday\n| tuesday : Weekday\n| wednesday : Weekday\n| thursday : Weekday\n| friday : Weekday\n| saturday : Weekday\nopen Weekday\n\ndef numberOfDay (d : Weekday) : Nat :=\n  match d with\n  | sunday    => 1\n  | monday    => 2\n  | tuesday   => 3\n  | wednesday => 4\n  | thursday  => 5\n  | friday    => 6\n  | saturday  => 7\n\n#eval numberOfDay Weekday.sunday  -- 1\n#eval numberOfDay Weekday.monday  -- 2\n#eval numberOfDay Weekday.tuesday -- 3\nNote that the\nmatch\nexpression is compiled using the\nrecursor\nWeekday.rec\ngenerated when\nyou declare the inductive type.\ninductive Weekday where\n| sunday : Weekday\n| monday : Weekday\n| tuesday : Weekday\n| wednesday : Weekday\n| thursday : Weekday\n| friday : Weekday\n| saturday : Weekday\nopen Weekday\n\ndef numberOfDay (d : Weekday) : Nat :=\n  match d with\n  | sunday    => 1\n  | monday    => 2\n  | tuesday   => 3\n  | wednesday => 4\n  | thursday  => 5\n  | friday    => 6\n  | saturday  => 7\n\nset_option pp.all true\n#print numberOfDay\n-- ... numberOfDay.match_1\n#print numberOfDay.match_1\n-- ... Weekday.casesOn ...\n#print Weekday.casesOn\n-- ... Weekday.rec ...\n#check @Weekday.rec\n/-\n@Weekday.rec.{u}\n : {motive : Weekday → Sort u} →\n    motive Weekday.sunday →\n    motive Weekday.monday →\n    motive Weekday.tuesday →\n    motive Weekday.wednesday →\n    motive Weekday.thursday →\n    motive Weekday.friday →\n    motive Weekday.saturday →\n    (t : Weekday) → motive t\n-/\nWhen declaring an inductive datatype, you can use\nderiving Repr\nto instruct\nLean to generate a function that converts\nWeekday\nobjects into text.\nThis function is used by the\n#eval\ncommand to display\nWeekday\nobjects.\ninductive Weekday where\n  | sunday\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  deriving Repr\n\nopen Weekday\n\n#eval tuesday   -- Weekday.tuesday\nIt is often useful to group definitions and theorems related to a\nstructure in a namespace with the same name. For example, we can put\nthe\nnumberOfDay\nfunction in the\nWeekday\nnamespace. We are\nthen allowed to use the shorter name when we open the namespace.\nWe can define functions from\nWeekday\nto\nWeekday\n:\ninductive Weekday where\n| sunday : Weekday\n| monday : Weekday\n| tuesday : Weekday\n| wednesday : Weekday\n| thursday : Weekday\n| friday : Weekday\n| saturday : Weekday\nderiving Repr\nnamespace Weekday\ndef next (d : Weekday) : Weekday :=\n  match d with\n  | sunday    => monday\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => saturday\n  | saturday  => sunday\n\ndef previous (d : Weekday) : Weekday :=\n  match d with\n  | sunday    => saturday\n  | monday    => sunday\n  | tuesday   => monday\n  | wednesday => tuesday\n  | thursday  => wednesday\n  | friday    => thursday\n  | saturday  => friday\n\n#eval next (next tuesday)      -- Weekday.thursday\n#eval next (previous tuesday)  -- Weekday.tuesday\n\nexample : next (previous tuesday) = tuesday :=\n  rfl\n\nend Weekday\nHow can we prove the general theorem that\nnext (previous d) = d\nfor any Weekday\nd\n? You can use\nmatch\nto provide a proof of the claim for each\nconstructor:\ninductive Weekday where\n| sunday : Weekday\n| monday : Weekday\n| tuesday : Weekday\n| wednesday : Weekday\n| thursday : Weekday\n| friday : Weekday\n| saturday : Weekday\nderiving Repr\nnamespace Weekday\ndef next (d : Weekday) : Weekday :=\nmatch d with\n| sunday    => monday\n| monday    => tuesday\n| tuesday   => wednesday\n| wednesday => thursday\n| thursday  => friday\n| friday    => saturday\n| saturday  => sunday\ndef previous (d : Weekday) : Weekday :=\nmatch d with\n| sunday    => saturday\n| monday    => sunday\n| tuesday   => monday\n| wednesday => tuesday\n| thursday  => wednesday\n| friday    => thursday\n| saturday  => friday\ndef next_previous (d : Weekday) : next (previous d) = d :=\n  match d with\n  | sunday    => rfl\n  | monday    => rfl\n  | tuesday   => rfl\n  | wednesday => rfl\n  | thursday  => rfl\n  | friday    => rfl\n  | saturday  => rfl\nUsing a tactic proof, we can be even more concise:\ninductive Weekday where\n| sunday : Weekday\n| monday : Weekday\n| tuesday : Weekday\n| wednesday : Weekday\n| thursday : Weekday\n| friday : Weekday\n| saturday : Weekday\nderiving Repr\nnamespace Weekday\ndef next (d : Weekday) : Weekday :=\nmatch d with\n| sunday    => monday\n| monday    => tuesday\n| tuesday   => wednesday\n| wednesday => thursday\n| thursday  => friday\n| friday    => saturday\n| saturday  => sunday\ndef previous (d : Weekday) : Weekday :=\nmatch d with\n| sunday    => saturday\n| monday    => sunday\n| tuesday   => monday\n| wednesday => tuesday\n| thursday  => wednesday\n| friday    => thursday\n| saturday  => friday\ndef next_previous (d : Weekday) : next (previous d) = d := by\n  cases d <;> rfl\nTactics for Inductive Types\nbelow will introduce additional\ntactics that are specifically designed to make use of inductive types.\nNotice that, under the propositions-as-types correspondence, we can\nuse\nmatch\nto prove theorems as well as define functions.  In other\nwords, under the propositions-as-types correspondence, the proof by\ncases is a kind of definition by cases, where what is being "defined"\nis a proof instead of a piece of data.\nThe\nBool\ntype in the Lean library is an instance of\nenumerated type.\nnamespace Hidden\ninductive Bool where\n  | false : Bool\n  | true  : Bool\nend Hidden\n(To run these examples, we put them in a namespace called\nHidden\n,\nso that a name like\nBool\ndoes not conflict with the\nBool\nin\nthe standard library. This is necessary because these types are part\nof the Lean "prelude" that is automatically imported when the system\nis started.)\nAs an exercise, you should think about what the introduction and\nelimination rules for these types do. As a further exercise, we\nsuggest defining boolean operations\nand\n,\nor\n,\nnot\non the\nBool\ntype, and verifying common identities. Note that you can define a\nbinary operation like\nand\nusing\nmatch\n:\nnamespace Hidden\ndef and (a b : Bool) : Bool :=\n  match a with\n  | true  => b\n  | false => false\nend Hidden\nSimilarly, most identities can be proved by introducing suitable\nmatch\n, and then using\nrfl\n.\nConstructors with Arguments\nEnumerated types are a very special case of inductive types, in which\nthe constructors take no arguments at all. In general, a\n"construction" can depend on data, which is then represented in the\nconstructed argument. Consider the definitions of the product type and\nsum type in the library:\nnamespace Hidden\ninductive Prod (α : Type u) (β : Type v)\n  | mk : α → β → Prod α β\n\ninductive Sum (α : Type u) (β : Type v) where\n  | inl : α → Sum α β\n  | inr : β → Sum α β\nend Hidden\nConsider what is going on in these examples.\nThe product type has one constructor,\nProd.mk\n,\nwhich takes two arguments. To define a function on\nProd α β\n, we\ncan assume the input is of the form\nProd.mk a b\n, and we have to\nspecify the output, in terms of\na\nand\nb\n. We can use this to\ndefine the two projections for\nProd\n. Remember that the standard\nlibrary defines notation\nα × β\nfor\nProd α β\nand\n(a, b)\nfor\nProd.mk a b\n.\nnamespace Hidden\ninductive Prod (α : Type u) (β : Type v)\n| mk : α → β → Prod α β\ndef fst {α : Type u} {β : Type v} (p : Prod α β) : α :=\n  match p with\n  | Prod.mk a b => a\n\ndef snd {α : Type u} {β : Type v} (p : Prod α β) : β :=\n  match p with\n  | Prod.mk a b => b\nend Hidden\nThe function\nfst\ntakes a pair,\np\n. The\nmatch\ninterprets\np\nas a pair,\nProd.mk a b\n. Recall also from\nDependent Type Theory\nthat to give these definitions the greatest generality possible, we allow\nthe types\nα\nand\nβ\nto belong to any universe.\nHere is another example where we use the recursor\nProd.casesOn\ninstead\nof\nmatch\n.\ndef prod_example (p : Bool × Nat) : Nat :=\n  Prod.casesOn (motive := fun _ => Nat) p (fun b n => cond b (2 * n) (2 * n + 1))\n\n#eval prod_example (true, 3)\n#eval prod_example (false, 3)\nThe argument\nmotive\nis used to specify the type of the object you want to\nconstruct, and it is a function because it may depend on the pair.\nThe\ncond\nfunction is a boolean conditional:\ncond b t1 t2\nreturns\nt1\nif\nb\nis true, and\nt2\notherwise.\nThe function\nprod_example\ntakes a pair consisting of a boolean,\nb\n, and a number,\nn\n, and returns either\n2 * n\nor\n2 * n + 1\naccording to whether\nb\nis true or false.\nIn contrast, the sum type has\ntwo\nconstructors,\ninl\nand\ninr\n(for "insert left" and "insert right"), each of which takes\none\n(explicit) argument. To define a function on\nSum α β\n, we have to\nhandle two cases: either the input is of the form\ninl a\n, in which\ncase we have to specify an output value in terms of\na\n, or the\ninput is of the form\ninr b\n, in which case we have to specify an\noutput value in terms of\nb\n.\ndef sum_example (s : Sum Nat Nat) : Nat :=\n  Sum.casesOn (motive := fun _ => Nat) s\n    (fun n => 2 * n)\n    (fun n => 2 * n + 1)\n\n#eval sum_example (Sum.inl 3)\n#eval sum_example (Sum.inr 3)\nThis example is similar to the previous one, but now an input to\nsum_example\nis implicitly either of the form\ninl n\nor\ninr n\n.\nIn the first case, the function returns\n2 * n\n, and the second\ncase, it returns\n2 * n + 1\n.\nNotice that the product type depends on parameters\nα β : Type\nwhich are arguments to the constructors as well as\nProd\n. Lean\ndetects when these arguments can be inferred from later arguments to a\nconstructor or the return type, and makes them implicit in that case.\nIn\nSection Defining the Natural Numbers\nwe will see what happens when the\nconstructor of an inductive type takes arguments from the inductive\ntype itself. What characterizes the examples we consider in this\nsection is that each constructor relies only on previously specified types.\nNotice that a type with multiple constructors is disjunctive: an\nelement of\nSum α β\nis either of the form\ninl a\nor\nof the\nform\ninl b\n. A constructor with multiple arguments introduces\nconjunctive information: from an element\nProd.mk a b\nof\nProd α β\nwe can extract\na\nand\nb\n. An arbitrary inductive type can\ninclude both features, by having any number of constructors, each of\nwhich takes any number of arguments.\nAs with function definitions, Lean\'s inductive definition syntax will\nlet you put named arguments to the constructors before the colon:\nnamespace Hidden\ninductive Prod (α : Type u) (β : Type v) where\n  | mk (fst : α) (snd : β) : Prod α β\n\ninductive Sum (α : Type u) (β : Type v) where\n  | inl (a : α) : Sum α β\n  | inr (b : β) : Sum α β\nend Hidden\nThe results of these definitions are essentially the same as the ones given earlier in this section.\nA type, like\nProd\n, that has only one constructor is purely\nconjunctive: the constructor simply packs the list of arguments into a\nsingle piece of data, essentially a tuple where the type of subsequent\narguments can depend on the type of the initial argument. We can also\nthink of such a type as a "record" or a "structure". In Lean, the\nkeyword\nstructure\ncan be used to define such an inductive type as\nwell as its projections, at the same time.\nnamespace Hidden\nstructure Prod (α : Type u) (β : Type v) where\n  mk :: (fst : α) (snd : β)\nend Hidden\nThis example simultaneously introduces the inductive type,\nProd\n,\nits constructor,\nmk\n, the usual eliminators (\nrec\nand\nrecOn\n), as well as the projections,\nfst\nand\nsnd\n, as\ndefined above.\nIf you do not name the constructor, Lean uses\nmk\nas a default. For\nexample, the following defines a record to store a color as a triple\nof RGB values:\nstructure Color where\n  (red : Nat) (green : Nat) (blue : Nat)\n  deriving Repr\n\ndef yellow := Color.mk 255 255 0\n\n#eval Color.red yellow\nThe definition of\nyellow\nforms the record with the three values\nshown, and the projection\nColor.red\nreturns the red component.\nYou can avoid the parentheses if you add a line break between each field.\nstructure Color where\n  red : Nat\n  green : Nat\n  blue : Nat\n  deriving Repr\nThe\nstructure\ncommand is especially useful for defining algebraic\nstructures, and Lean provides substantial infrastructure to support\nworking with them. Here, for example, is the definition of a\nsemigroup:\nstructure Semigroup where\n  carrier : Type u\n  mul : carrier → carrier → carrier\n  mul_assoc : ∀ a b c, mul (mul a b) c = mul a (mul b c)\nWe will see more examples in\nChapter Structures and Records\n.\nWe have already discussed the dependent product type\nSigma\n:\nnamespace Hidden\ninductive Sigma {α : Type u} (β : α → Type v) where\n  | mk : (a : α) → β a → Sigma β\nend Hidden\nTwo more examples of inductive types in the library are the following:\nnamespace Hidden\ninductive Option (α : Type u) where\n  | none : Option α\n  | some : α → Option α\n\ninductive Inhabited (α : Type u) where\n  | mk : α → Inhabited α\nend Hidden\nIn the semantics of dependent type theory, there is no built-in notion\nof a partial function. Every element of a function type\nα → β\nor a\ndependent function type\n(a : α) → β\nis assumed to have a value\nat every input. The\nOption\ntype provides a way of representing partial functions. An\nelement of\nOption β\nis either\nnone\nor of the form\nsome b\n,\nfor some value\nb : β\n. Thus we can think of an element\nf\nof the\ntype\nα → Option β\nas being a partial function from\nα\nto\nβ\n:\nfor every\na : α\n,\nf a\neither returns\nnone\n, indicating\nf a\nis "undefined", or\nsome b\n.\nAn element of\nInhabited α\nis simply a witness to the fact that\nthere is an element of\nα\n. Later, we will see that\nInhabited\nis\nan example of a\ntype class\nin Lean: Lean can be instructed that\nsuitable base types are inhabited, and can automatically infer that\nother constructed types are inhabited on that basis.\nAs exercises, we encourage you to develop a notion of composition for\npartial functions from\nα\nto\nβ\nand\nβ\nto\nγ\n, and show\nthat it behaves as expected. We also encourage you to show that\nBool\nand\nNat\nare inhabited, that the product of two inhabited\ntypes is inhabited, and that the type of functions to an inhabited\ntype is inhabited.\nInductively Defined Propositions\nInductively defined types can live in any type universe, including the\nbottom-most one,\nProp\n. In fact, this is exactly how the logical\nconnectives are defined.\nnamespace Hidden\ninductive False : Prop\n\ninductive True : Prop where\n  | intro : True\n\ninductive And (a b : Prop) : Prop where\n  | intro : a → b → And a b\n\ninductive Or (a b : Prop) : Prop where\n  | inl : a → Or a b\n  | inr : b → Or a b\nend Hidden\nYou should think about how these give rise to the introduction and\nelimination rules that you have already seen. There are rules that\ngovern what the eliminator of an inductive type can eliminate\nto\n,\nthat is, what kinds of types can be the target of a recursor. Roughly\nspeaking, what characterizes inductive types in\nProp\nis that one\ncan only eliminate to other types in\nProp\n. This is consistent with\nthe understanding that if\np : Prop\n, an element\nhp : p\ncarries\nno data. There is a small exception to this rule, however, which we\nwill discuss below, in\nSection Inductive Families\n.\nEven the existential quantifier is inductively defined:\nnamespace Hidden\ninductive Exists {α : Sort u} (p : α → Prop) : Prop where\n  | intro (w : α) (h : p w) : Exists p\nend Hidden\nKeep in mind that the notation\n∃ x : α, p\nis syntactic sugar for\nExists (fun x : α => p)\n.\nThe definitions of\nFalse\n,\nTrue\n,\nAnd\n, and\nOr\nare\nperfectly analogous to the definitions of\nEmpty\n,\nUnit\n,\nProd\n, and\nSum\n. The difference is that the first group yields\nelements of\nProp\n, and the second yields elements of\nType u\nfor\nsome\nu\n. In a similar way,\n∃ x : α, p\nis a\nProp\n-valued\nvariant of\nΣ x : α, p\n.\nThis is a good place to mention another inductive type, denoted\n{x : α // p}\n, which is sort of a hybrid between\n∃ x : α, P\nand\nΣ x : α, P\n.\nnamespace Hidden\ninductive Subtype {α : Type u} (p : α → Prop) where\n  | mk : (x : α) → p x → Subtype p\nend Hidden\nIn fact, in Lean,\nSubtype\nis defined using the structure command:\nnamespace Hidden\nstructure Subtype {α : Sort u} (p : α → Prop) where\n  val : α\n  property : p val\nend Hidden\nThe notation\n{x : α // p x}\nis syntactic sugar for\nSubtype (fun x : α => p x)\n.\nIt is modeled after subset notation in set theory: the idea is that\n{x : α // p x}\ndenotes the collection of elements of\nα\nthat have property\np\n.\nDefining the Natural Numbers\nThe inductively defined types we have seen so far are "flat":\nconstructors wrap data and insert it into a type, and the\ncorresponding recursor unpacks the data and acts on it. Things get\nmuch more interesting when the constructors act on elements of the\nvery type being defined. A canonical example is the type\nNat\nof\nnatural numbers:\nnamespace Hidden\ninductive Nat where\n  | zero : Nat\n  | succ : Nat → Nat\nend Hidden\nThere are two constructors. We start with\nzero : Nat\n; it takes\nno arguments, so we have it from the start. In contrast, the\nconstructor\nsucc\ncan only be applied to a previously constructed\nNat\n. Applying it to\nzero\nyields\nsucc zero : Nat\n. Applying\nit again yields\nsucc (succ zero) : Nat\n, and so on. Intuitively,\nNat\nis the "smallest" type with these constructors, meaning that\nit is exhaustively (and freely) generated by starting with\nzero\nand applying\nsucc\nrepeatedly.\nAs before, the recursor for\nNat\nis designed to define a dependent\nfunction\nf\nfrom\nNat\nto any domain, that is, an element\nf\nof\n(n : Nat) → motive n\nfor some\nmotive : Nat → Sort u\n.\nIt has to handle two cases: the case where the input is\nzero\n, and the case where\nthe input is of the form\nsucc n\nfor some\nn : Nat\n. In the first\ncase, we simply specify a target value with the appropriate type, as\nbefore. In the second case, however, the recursor can assume that a\nvalue of\nf\nat\nn\nhas already been computed. As a result, the\nnext argument to the recursor specifies a value for\nf (succ n)\nin\nterms of\nn\nand\nf n\n. If we check the type of the recursor,\nnamespace Hidden\ninductive Nat where\n| zero : Nat\n| succ : Nat → Nat\n#check @Nat.rec\nend Hidden\nyou find the following:\n{motive : Nat → Sort u}\n  → motive Nat.zero\n  → ((n : Nat) → motive n → motive (Nat.succ n))\n  → (t : Nat) → motive t\nThe implicit argument,\nmotive\n, is the codomain of the function being defined.\nIn type theory it is common to say\nmotive\nis the\nmotive\nfor the elimination/recursion,\nsince it describes the kind of object we wish to construct.\nThe next two arguments specify how to compute the zero and successor cases, as described above.\nThey are also known as the\nminor premises\n.\nFinally, the\nt : Nat\n, is the input to the function. It is also known as the\nmajor premise\n.\nThe\nNat.recOn\nis similar to\nNat.rec\nbut the major premise occurs before the minor premises.\n@Nat.recOn :\n  {motive : Nat → Sort u}\n  → (t : Nat)\n  → motive Nat.zero\n  → ((n : Nat) → motive n → motive (Nat.succ n))\n  → motive t\nConsider, for example, the addition function\nadd m n\non the\nnatural numbers. Fixing\nm\n, we can define addition by recursion on\nn\n. In the base case, we set\nadd m zero\nto\nm\n. In the\nsuccessor step, assuming the value\nadd m n\nis already determined,\nwe define\nadd m (succ n)\nto be\nsucc (add m n)\n.\nnamespace Hidden\ninductive Nat where\n  | zero : Nat\n  | succ : Nat → Nat\n  deriving Repr\n\ndef add (m n : Nat) : Nat :=\n  match n with\n  | Nat.zero   => m\n  | Nat.succ n => Nat.succ (add m n)\n\nopen Nat\n\n#eval add (succ (succ zero)) (succ zero)\nend Hidden\nIt is useful to put such definitions into a namespace,\nNat\n. We can\nthen go on to define familiar notation in that namespace. The two\ndefining equations for addition now hold definitionally:\nnamespace Hidden\ninductive Nat where\n| zero : Nat\n| succ : Nat → Nat\nderiving Repr\nnamespace Nat\n\ndef add (m n : Nat) : Nat :=\n  match n with\n  | Nat.zero   => m\n  | Nat.succ n => Nat.succ (add m n)\n\ninstance : Add Nat where\n  add := add\n\ntheorem add_zero (m : Nat) : m + zero = m := rfl\ntheorem add_succ (m n : Nat) : m + succ n = succ (m + n) := rfl\n\nend Nat\nend Hidden\nWe will explain how the\ninstance\ncommand works in\nChapter Type Classes\n. In the examples below, we will use\nLean\'s version of the natural numbers.\nProving a fact like\nzero + m = m\n, however, requires a proof by induction.\nAs observed above, the induction principle is just a special case of the recursion principle,\nwhen the codomain\nmotive n\nis an element of\nProp\n. It represents the familiar\npattern of an inductive proof: to prove\n∀ n, motive n\n, first prove\nmotive 0\n,\nand then, for arbitrary\nn\n, assume\nih : motive n\nand prove\nmotive (succ n)\n.\nnamespace Hidden\nopen Nat\n\ntheorem zero_add (n : Nat) : 0 + n = n :=\n  Nat.recOn (motive := fun x => 0 + x = x)\n   n\n   (show 0 + 0 = 0 from rfl)\n   (fun (n : Nat) (ih : 0 + n = n) =>\n    show 0 + succ n = succ n from\n    calc 0 + succ n\n      _ = succ (0 + n) := rfl\n      _ = succ n       := by rw [ih])\nend Hidden\nNotice that, once again, when\nNat.recOn\nis used in the context of\na proof, it is really the induction principle in disguise. The\nrewrite\nand\nsimp\ntactics tend to be very effective in proofs\nlike these. In this case, each can be used to reduce the proof to:\nnamespace Hidden\nopen Nat\n\ntheorem zero_add (n : Nat) : 0 + n = n :=\n  Nat.recOn (motive := fun x => 0 + x = x) n\n    rfl\n    (fun n ih => by simp [add_succ, ih])\nend Hidden\nAs another example, let us prove the associativity of addition,\n∀ m n k, m + n + k = m + (n + k)\n.\n(The notation\n+\n, as we have defined it, associates to the left, so\nm + n + k\nis really\n(m + n) + k\n.)\nThe hardest part is figuring out which variable to do the induction on. Since addition is defined by recursion on the second argument,\nk\nis a good guess, and once we make that choice the proof almost writes itself:\nnamespace Hidden\nopen Nat\ntheorem add_assoc (m n k : Nat) : m + n + k = m + (n + k) :=\n  Nat.recOn (motive := fun k => m + n + k = m + (n + k)) k\n    (show m + n + 0 = m + (n + 0) from rfl)\n    (fun k (ih : m + n + k = m + (n + k)) =>\n      show m + n + succ k = m + (n + succ k) from\n      calc m + n + succ k\n        _ = succ (m + n + k)   := rfl\n        _ = succ (m + (n + k)) := by rw [ih]\n        _ = m + succ (n + k)   := rfl\n        _ = m + (n + succ k)   := rfl)\nend Hidden\nOnce again, you can reduce the proof to:\nopen Nat\ntheorem add_assoc (m n k : Nat) : m + n + k = m + (n + k) :=\n  Nat.recOn (motive := fun k => m + n + k = m + (n + k)) k\n    rfl\n    (fun k ih => by simp [Nat.add_succ, ih])\nSuppose we try to prove the commutativity of addition. Choosing induction on the second argument, we might begin as follows:\nopen Nat\ntheorem add_comm (m n : Nat) : m + n = n + m :=\n  Nat.recOn (motive := fun x => m + x = x + m) n\n   (show m + 0 = 0 + m by rw [Nat.zero_add, Nat.add_zero])\n   (fun (n : Nat) (ih : m + n = n + m) =>\n    show m + succ n = succ n + m from\n    calc m + succ n\n      _ = succ (m + n) := rfl\n      _ = succ (n + m) := by rw [ih]\n      _ = succ n + m   := sorry)\nAt this point, we see that we need another supporting fact, namely, that\nsucc (n + m) = succ n + m\n.\nYou can prove this by induction on\nm\n:\nopen Nat\n\ntheorem succ_add (n m : Nat) : succ n + m = succ (n + m) :=\n  Nat.recOn (motive := fun x => succ n + x = succ (n + x)) m\n    (show succ n + 0 = succ (n + 0) from rfl)\n    (fun (m : Nat) (ih : succ n + m = succ (n + m)) =>\n     show succ n + succ m = succ (n + succ m) from\n     calc succ n + succ m\n       _ = succ (succ n + m)   := rfl\n       _ = succ (succ (n + m)) := by rw [ih]\n       _ = succ (n + succ m)   := rfl)\nYou can then replace the\nsorry\nin the previous proof with\nsucc_add\n. Yet again, the proofs can be compressed:\nnamespace Hidden\nopen Nat\ntheorem succ_add (n m : Nat) : succ n + m = succ (n + m) :=\n  Nat.recOn (motive := fun x => succ n + x = succ (n + x)) m\n    rfl\n    (fun m ih => by simp only [add_succ, ih])\n\ntheorem add_comm (m n : Nat) : m + n = n + m :=\n  Nat.recOn (motive := fun x => m + x = x + m) n\n    (by simp)\n    (fun m ih', 'model': 'text-embedding-3-small', 'encoding_format': 'base64'}}
2025-05-31 17:23:46,230 - DEBUG - Sending HTTP Request: POST https://api.openai.com/v1/embeddings
2025-05-31 17:23:46,231 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-05-31 17:23:46,231 - DEBUG - send_request_headers.complete
2025-05-31 17:23:46,231 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-05-31 17:23:46,231 - DEBUG - send_request_body.complete
2025-05-31 17:23:46,231 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-05-31 17:23:46,819 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 429, b'Too Many Requests', [(b'Date', b'Sat, 31 May 2025 17:23:46 GMT'), (b'Content-Type', b'application/json; charset=utf-8'), (b'Content-Length', b'337'), (b'Connection', b'keep-alive'), (b'vary', b'Origin'), (b'x-request-id', b'req_9304141ccd5852cecf419b160cfabbd8'), (b'strict-transport-security', b'max-age=31536000; includeSubDomains; preload'), (b'cf-cache-status', b'DYNAMIC'), (b'X-Content-Type-Options', b'nosniff'), (b'Server', b'cloudflare'), (b'CF-RAY', b'94882935edb23b10-BOM'), (b'alt-svc', b'h3=":443"; ma=86400')])
2025-05-31 17:23:46,819 - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 429 Too Many Requests"
2025-05-31 17:23:46,819 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-05-31 17:23:46,819 - DEBUG - receive_response_body.complete
2025-05-31 17:23:46,819 - DEBUG - response_closed.started
2025-05-31 17:23:46,819 - DEBUG - response_closed.complete
2025-05-31 17:23:46,820 - DEBUG - HTTP Response: POST https://api.openai.com/v1/embeddings "429 Too Many Requests" Headers({'date': 'Sat, 31 May 2025 17:23:46 GMT', 'content-type': 'application/json; charset=utf-8', 'content-length': '337', 'connection': 'keep-alive', 'vary': 'Origin', 'x-request-id': 'req_9304141ccd5852cecf419b160cfabbd8', 'strict-transport-security': 'max-age=31536000; includeSubDomains; preload', 'cf-cache-status': 'DYNAMIC', 'x-content-type-options': 'nosniff', 'server': 'cloudflare', 'cf-ray': '94882935edb23b10-BOM', 'alt-svc': 'h3=":443"; ma=86400'})
2025-05-31 17:23:46,820 - DEBUG - request_id: req_9304141ccd5852cecf419b160cfabbd8
2025-05-31 17:23:46,820 - DEBUG - Encountered httpx.HTTPStatusError
Traceback (most recent call last):
  File "/usr/local/lib/python3.12/dist-packages/openai/_base_client.py", line 1007, in _request
    response.raise_for_status()
  File "/usr/local/lib/python3.12/dist-packages/httpx/_models.py", line 829, in raise_for_status
    raise HTTPStatusError(message, request=request, response=self)
httpx.HTTPStatusError: Client error '429 Too Many Requests' for url 'https://api.openai.com/v1/embeddings'
For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/usr/local/lib/python3.12/dist-packages/openai/_base_client.py", line 1007, in _request
    response.raise_for_status()
  File "/usr/local/lib/python3.12/dist-packages/httpx/_models.py", line 829, in raise_for_status
    raise HTTPStatusError(message, request=request, response=self)
httpx.HTTPStatusError: Client error '429 Too Many Requests' for url 'https://api.openai.com/v1/embeddings'
For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429
2025-05-31 17:23:46,820 - DEBUG - Retrying due to status code 429
2025-05-31 17:23:46,820 - DEBUG - 1 retry left
2025-05-31 17:23:46,820 - INFO - Retrying request to /embeddings in 0.819070 seconds
2025-05-31 17:23:47,640 - DEBUG - Request options: {'method': 'post', 'url': '/embeddings', 'files': None, 'post_parser': <function Embeddings.create.<locals>.parser at 0x7e1edd764540>, 'json_data': {'input': 'Inductive Types - Theorem Proving in Lean 4\nTheorem Proving in Lean 4\n1.\nIntroduction\n2.\nDependent Type Theory\n3.\nPropositions and Proofs\n4.\nQuantifiers and Equality\n5.\nTactics\n6.\nInteracting with Lean\n7.\nInductive Types\n8.\nInduction and Recursion\n9.\nStructures and Records\n10.\nType Classes\n11.\nThe Conversion Tactic Mode\n12.\nAxioms and Computation\nLight (default)\nRust\nCoal\nNavy\nAyu\nTheorem Proving in Lean 4\nInductive Types\nWe have seen that Lean\'s formal foundation includes basic types,\nProp, Type 0, Type 1, Type 2, ...\n, and allows for the formation of\ndependent function types,\n(x : α) → β\n. In the examples, we have\nalso made use of additional types like\nBool\n,\nNat\n, and\nInt\n,\nand type constructors, like\nList\n, and product,\n×\n. In fact, in\nLean\'s library, every concrete type other than the universes and every\ntype constructor other than dependent arrows is an instance of a general family of\ntype constructions known as\ninductive types\n. It is remarkable that\nit is possible to construct a substantial edifice of mathematics based\non nothing more than the type universes, dependent arrow types, and inductive\ntypes; everything else follows from those.\nIntuitively, an inductive type is built up from a specified list of\nconstructors. In Lean, the syntax for specifying such a type is as\nfollows:\ninductive Foo where\n  | constructor₁ : ... → Foo\n  | constructor₂ : ... → Foo\n  ...\n  | constructorₙ : ... → Foo\nThe intuition is that each constructor specifies a way of building new\nobjects of\nFoo\n, possibly from previously constructed values. The\ntype\nFoo\nconsists of nothing more than the objects that are\nconstructed in this way. The first character\n|\nin an inductive\ndeclaration is optional. We can also separate constructors using a\ncomma instead of\n|\n.\nWe will see below that the arguments of the constructors can include\nobjects of type\nFoo\n, subject to a certain "positivity" constraint,\nwhich guarantees that elements of\nFoo\nare built from the bottom\nup. Roughly speaking, each\n...\ncan be any arrow type constructed from\nFoo\nand previously defined types, in which\nFoo\nappears, if at\nall, only as the "target" of the dependent arrow type.\nWe will provide a number of examples of inductive types. We will also\nconsider slight generalizations of the scheme above, to mutually\ndefined inductive types, and so-called\ninductive families\n.\nAs with the logical connectives, every inductive type comes with\nintroduction rules, which show how to construct an element of the\ntype, and elimination rules, which show how to "use" an element of the\ntype in another construction. The analogy to the logical connectives\nshould not come as a surprise; as we will see below, they, too, are\nexamples of inductive type constructions. You have already seen the\nintroduction rules for an inductive type: they are just the\nconstructors that are specified in the definition of the type. The\nelimination rules provide for a principle of recursion on the type,\nwhich includes, as a special case, a principle of induction as well.\nIn the next chapter, we will describe Lean\'s function definition\npackage, which provides even more convenient ways to define functions\non inductive types and carry out inductive proofs. But because the\nnotion of an inductive type is so fundamental, we feel it is important\nto start with a low-level, hands-on understanding. We will start with\nsome basic examples of inductive types, and work our way up to more\nelaborate and complex examples.\nEnumerated Types\nThe simplest kind of inductive type is a type with a finite, enumerated list of elements.\ninductive Weekday where\n  | sunday : Weekday\n  | monday : Weekday\n  | tuesday : Weekday\n  | wednesday : Weekday\n  | thursday : Weekday\n  | friday : Weekday\n  | saturday : Weekday\nThe\ninductive\ncommand creates a new type,\nWeekday\n. The\nconstructors all live in the\nWeekday\nnamespace.\ninductive Weekday where\n| sunday : Weekday\n| monday : Weekday\n| tuesday : Weekday\n| wednesday : Weekday\n| thursday : Weekday\n| friday : Weekday\n| saturday : Weekday\n#check Weekday.sunday\n#check Weekday.monday\n\nopen Weekday\n\n#check sunday\n#check monday\nYou can omit\n: Weekday\nwhen declaring the\nWeekday\ninductive type.\ninductive Weekday where\n  | sunday\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\nThink of\nsunday\n,\nmonday\n, ... ,\nsaturday\nas\nbeing distinct elements of\nWeekday\n, with no other distinguishing\nproperties. The elimination principle,\nWeekday.rec\n, is defined\nalong with the type\nWeekday\nand its constructors. It is also known\nas a\nrecursor\n, and it is what makes the type "inductive": it allows\nus to define a function on\nWeekday\nby assigning values\ncorresponding to each constructor. The intuition is that an inductive\ntype is exhaustively generated by the constructors, and has no\nelements beyond those they construct.\nWe will use the\nmatch\nexpression to define a function from\nWeekday\nto the natural numbers:\ninductive Weekday where\n| sunday : Weekday\n| monday : Weekday\n| tuesday : Weekday\n| wednesday : Weekday\n| thursday : Weekday\n| friday : Weekday\n| saturday : Weekday\nopen Weekday\n\ndef numberOfDay (d : Weekday) : Nat :=\n  match d with\n  | sunday    => 1\n  | monday    => 2\n  | tuesday   => 3\n  | wednesday => 4\n  | thursday  => 5\n  | friday    => 6\n  | saturday  => 7\n\n#eval numberOfDay Weekday.sunday  -- 1\n#eval numberOfDay Weekday.monday  -- 2\n#eval numberOfDay Weekday.tuesday -- 3\nNote that the\nmatch\nexpression is compiled using the\nrecursor\nWeekday.rec\ngenerated when\nyou declare the inductive type.\ninductive Weekday where\n| sunday : Weekday\n| monday : Weekday\n| tuesday : Weekday\n| wednesday : Weekday\n| thursday : Weekday\n| friday : Weekday\n| saturday : Weekday\nopen Weekday\n\ndef numberOfDay (d : Weekday) : Nat :=\n  match d with\n  | sunday    => 1\n  | monday    => 2\n  | tuesday   => 3\n  | wednesday => 4\n  | thursday  => 5\n  | friday    => 6\n  | saturday  => 7\n\nset_option pp.all true\n#print numberOfDay\n-- ... numberOfDay.match_1\n#print numberOfDay.match_1\n-- ... Weekday.casesOn ...\n#print Weekday.casesOn\n-- ... Weekday.rec ...\n#check @Weekday.rec\n/-\n@Weekday.rec.{u}\n : {motive : Weekday → Sort u} →\n    motive Weekday.sunday →\n    motive Weekday.monday →\n    motive Weekday.tuesday →\n    motive Weekday.wednesday →\n    motive Weekday.thursday →\n    motive Weekday.friday →\n    motive Weekday.saturday →\n    (t : Weekday) → motive t\n-/\nWhen declaring an inductive datatype, you can use\nderiving Repr\nto instruct\nLean to generate a function that converts\nWeekday\nobjects into text.\nThis function is used by the\n#eval\ncommand to display\nWeekday\nobjects.\ninductive Weekday where\n  | sunday\n  | monday\n  | tuesday\n  | wednesday\n  | thursday\n  | friday\n  | saturday\n  deriving Repr\n\nopen Weekday\n\n#eval tuesday   -- Weekday.tuesday\nIt is often useful to group definitions and theorems related to a\nstructure in a namespace with the same name. For example, we can put\nthe\nnumberOfDay\nfunction in the\nWeekday\nnamespace. We are\nthen allowed to use the shorter name when we open the namespace.\nWe can define functions from\nWeekday\nto\nWeekday\n:\ninductive Weekday where\n| sunday : Weekday\n| monday : Weekday\n| tuesday : Weekday\n| wednesday : Weekday\n| thursday : Weekday\n| friday : Weekday\n| saturday : Weekday\nderiving Repr\nnamespace Weekday\ndef next (d : Weekday) : Weekday :=\n  match d with\n  | sunday    => monday\n  | monday    => tuesday\n  | tuesday   => wednesday\n  | wednesday => thursday\n  | thursday  => friday\n  | friday    => saturday\n  | saturday  => sunday\n\ndef previous (d : Weekday) : Weekday :=\n  match d with\n  | sunday    => saturday\n  | monday    => sunday\n  | tuesday   => monday\n  | wednesday => tuesday\n  | thursday  => wednesday\n  | friday    => thursday\n  | saturday  => friday\n\n#eval next (next tuesday)      -- Weekday.thursday\n#eval next (previous tuesday)  -- Weekday.tuesday\n\nexample : next (previous tuesday) = tuesday :=\n  rfl\n\nend Weekday\nHow can we prove the general theorem that\nnext (previous d) = d\nfor any Weekday\nd\n? You can use\nmatch\nto provide a proof of the claim for each\nconstructor:\ninductive Weekday where\n| sunday : Weekday\n| monday : Weekday\n| tuesday : Weekday\n| wednesday : Weekday\n| thursday : Weekday\n| friday : Weekday\n| saturday : Weekday\nderiving Repr\nnamespace Weekday\ndef next (d : Weekday) : Weekday :=\nmatch d with\n| sunday    => monday\n| monday    => tuesday\n| tuesday   => wednesday\n| wednesday => thursday\n| thursday  => friday\n| friday    => saturday\n| saturday  => sunday\ndef previous (d : Weekday) : Weekday :=\nmatch d with\n| sunday    => saturday\n| monday    => sunday\n| tuesday   => monday\n| wednesday => tuesday\n| thursday  => wednesday\n| friday    => thursday\n| saturday  => friday\ndef next_previous (d : Weekday) : next (previous d) = d :=\n  match d with\n  | sunday    => rfl\n  | monday    => rfl\n  | tuesday   => rfl\n  | wednesday => rfl\n  | thursday  => rfl\n  | friday    => rfl\n  | saturday  => rfl\nUsing a tactic proof, we can be even more concise:\ninductive Weekday where\n| sunday : Weekday\n| monday : Weekday\n| tuesday : Weekday\n| wednesday : Weekday\n| thursday : Weekday\n| friday : Weekday\n| saturday : Weekday\nderiving Repr\nnamespace Weekday\ndef next (d : Weekday) : Weekday :=\nmatch d with\n| sunday    => monday\n| monday    => tuesday\n| tuesday   => wednesday\n| wednesday => thursday\n| thursday  => friday\n| friday    => saturday\n| saturday  => sunday\ndef previous (d : Weekday) : Weekday :=\nmatch d with\n| sunday    => saturday\n| monday    => sunday\n| tuesday   => monday\n| wednesday => tuesday\n| thursday  => wednesday\n| friday    => thursday\n| saturday  => friday\ndef next_previous (d : Weekday) : next (previous d) = d := by\n  cases d <;> rfl\nTactics for Inductive Types\nbelow will introduce additional\ntactics that are specifically designed to make use of inductive types.\nNotice that, under the propositions-as-types correspondence, we can\nuse\nmatch\nto prove theorems as well as define functions.  In other\nwords, under the propositions-as-types correspondence, the proof by\ncases is a kind of definition by cases, where what is being "defined"\nis a proof instead of a piece of data.\nThe\nBool\ntype in the Lean library is an instance of\nenumerated type.\nnamespace Hidden\ninductive Bool where\n  | false : Bool\n  | true  : Bool\nend Hidden\n(To run these examples, we put them in a namespace called\nHidden\n,\nso that a name like\nBool\ndoes not conflict with the\nBool\nin\nthe standard library. This is necessary because these types are part\nof the Lean "prelude" that is automatically imported when the system\nis started.)\nAs an exercise, you should think about what the introduction and\nelimination rules for these types do. As a further exercise, we\nsuggest defining boolean operations\nand\n,\nor\n,\nnot\non the\nBool\ntype, and verifying common identities. Note that you can define a\nbinary operation like\nand\nusing\nmatch\n:\nnamespace Hidden\ndef and (a b : Bool) : Bool :=\n  match a with\n  | true  => b\n  | false => false\nend Hidden\nSimilarly, most identities can be proved by introducing suitable\nmatch\n, and then using\nrfl\n.\nConstructors with Arguments\nEnumerated types are a very special case of inductive types, in which\nthe constructors take no arguments at all. In general, a\n"construction" can depend on data, which is then represented in the\nconstructed argument. Consider the definitions of the product type and\nsum type in the library:\nnamespace Hidden\ninductive Prod (α : Type u) (β : Type v)\n  | mk : α → β → Prod α β\n\ninductive Sum (α : Type u) (β : Type v) where\n  | inl : α → Sum α β\n  | inr : β → Sum α β\nend Hidden\nConsider what is going on in these examples.\nThe product type has one constructor,\nProd.mk\n,\nwhich takes two arguments. To define a function on\nProd α β\n, we\ncan assume the input is of the form\nProd.mk a b\n, and we have to\nspecify the output, in terms of\na\nand\nb\n. We can use this to\ndefine the two projections for\nProd\n. Remember that the standard\nlibrary defines notation\nα × β\nfor\nProd α β\nand\n(a, b)\nfor\nProd.mk a b\n.\nnamespace Hidden\ninductive Prod (α : Type u) (β : Type v)\n| mk : α → β → Prod α β\ndef fst {α : Type u} {β : Type v} (p : Prod α β) : α :=\n  match p with\n  | Prod.mk a b => a\n\ndef snd {α : Type u} {β : Type v} (p : Prod α β) : β :=\n  match p with\n  | Prod.mk a b => b\nend Hidden\nThe function\nfst\ntakes a pair,\np\n. The\nmatch\ninterprets\np\nas a pair,\nProd.mk a b\n. Recall also from\nDependent Type Theory\nthat to give these definitions the greatest generality possible, we allow\nthe types\nα\nand\nβ\nto belong to any universe.\nHere is another example where we use the recursor\nProd.casesOn\ninstead\nof\nmatch\n.\ndef prod_example (p : Bool × Nat) : Nat :=\n  Prod.casesOn (motive := fun _ => Nat) p (fun b n => cond b (2 * n) (2 * n + 1))\n\n#eval prod_example (true, 3)\n#eval prod_example (false, 3)\nThe argument\nmotive\nis used to specify the type of the object you want to\nconstruct, and it is a function because it may depend on the pair.\nThe\ncond\nfunction is a boolean conditional:\ncond b t1 t2\nreturns\nt1\nif\nb\nis true, and\nt2\notherwise.\nThe function\nprod_example\ntakes a pair consisting of a boolean,\nb\n, and a number,\nn\n, and returns either\n2 * n\nor\n2 * n + 1\naccording to whether\nb\nis true or false.\nIn contrast, the sum type has\ntwo\nconstructors,\ninl\nand\ninr\n(for "insert left" and "insert right"), each of which takes\none\n(explicit) argument. To define a function on\nSum α β\n, we have to\nhandle two cases: either the input is of the form\ninl a\n, in which\ncase we have to specify an output value in terms of\na\n, or the\ninput is of the form\ninr b\n, in which case we have to specify an\noutput value in terms of\nb\n.\ndef sum_example (s : Sum Nat Nat) : Nat :=\n  Sum.casesOn (motive := fun _ => Nat) s\n    (fun n => 2 * n)\n    (fun n => 2 * n + 1)\n\n#eval sum_example (Sum.inl 3)\n#eval sum_example (Sum.inr 3)\nThis example is similar to the previous one, but now an input to\nsum_example\nis implicitly either of the form\ninl n\nor\ninr n\n.\nIn the first case, the function returns\n2 * n\n, and the second\ncase, it returns\n2 * n + 1\n.\nNotice that the product type depends on parameters\nα β : Type\nwhich are arguments to the constructors as well as\nProd\n. Lean\ndetects when these arguments can be inferred from later arguments to a\nconstructor or the return type, and makes them implicit in that case.\nIn\nSection Defining the Natural Numbers\nwe will see what happens when the\nconstructor of an inductive type takes arguments from the inductive\ntype itself. What characterizes the examples we consider in this\nsection is that each constructor relies only on previously specified types.\nNotice that a type with multiple constructors is disjunctive: an\nelement of\nSum α β\nis either of the form\ninl a\nor\nof the\nform\ninl b\n. A constructor with multiple arguments introduces\nconjunctive information: from an element\nProd.mk a b\nof\nProd α β\nwe can extract\na\nand\nb\n. An arbitrary inductive type can\ninclude both features, by having any number of constructors, each of\nwhich takes any number of arguments.\nAs with function definitions, Lean\'s inductive definition syntax will\nlet you put named arguments to the constructors before the colon:\nnamespace Hidden\ninductive Prod (α : Type u) (β : Type v) where\n  | mk (fst : α) (snd : β) : Prod α β\n\ninductive Sum (α : Type u) (β : Type v) where\n  | inl (a : α) : Sum α β\n  | inr (b : β) : Sum α β\nend Hidden\nThe results of these definitions are essentially the same as the ones given earlier in this section.\nA type, like\nProd\n, that has only one constructor is purely\nconjunctive: the constructor simply packs the list of arguments into a\nsingle piece of data, essentially a tuple where the type of subsequent\narguments can depend on the type of the initial argument. We can also\nthink of such a type as a "record" or a "structure". In Lean, the\nkeyword\nstructure\ncan be used to define such an inductive type as\nwell as its projections, at the same time.\nnamespace Hidden\nstructure Prod (α : Type u) (β : Type v) where\n  mk :: (fst : α) (snd : β)\nend Hidden\nThis example simultaneously introduces the inductive type,\nProd\n,\nits constructor,\nmk\n, the usual eliminators (\nrec\nand\nrecOn\n), as well as the projections,\nfst\nand\nsnd\n, as\ndefined above.\nIf you do not name the constructor, Lean uses\nmk\nas a default. For\nexample, the following defines a record to store a color as a triple\nof RGB values:\nstructure Color where\n  (red : Nat) (green : Nat) (blue : Nat)\n  deriving Repr\n\ndef yellow := Color.mk 255 255 0\n\n#eval Color.red yellow\nThe definition of\nyellow\nforms the record with the three values\nshown, and the projection\nColor.red\nreturns the red component.\nYou can avoid the parentheses if you add a line break between each field.\nstructure Color where\n  red : Nat\n  green : Nat\n  blue : Nat\n  deriving Repr\nThe\nstructure\ncommand is especially useful for defining algebraic\nstructures, and Lean provides substantial infrastructure to support\nworking with them. Here, for example, is the definition of a\nsemigroup:\nstructure Semigroup where\n  carrier : Type u\n  mul : carrier → carrier → carrier\n  mul_assoc : ∀ a b c, mul (mul a b) c = mul a (mul b c)\nWe will see more examples in\nChapter Structures and Records\n.\nWe have already discussed the dependent product type\nSigma\n:\nnamespace Hidden\ninductive Sigma {α : Type u} (β : α → Type v) where\n  | mk : (a : α) → β a → Sigma β\nend Hidden\nTwo more examples of inductive types in the library are the following:\nnamespace Hidden\ninductive Option (α : Type u) where\n  | none : Option α\n  | some : α → Option α\n\ninductive Inhabited (α : Type u) where\n  | mk : α → Inhabited α\nend Hidden\nIn the semantics of dependent type theory, there is no built-in notion\nof a partial function. Every element of a function type\nα → β\nor a\ndependent function type\n(a : α) → β\nis assumed to have a value\nat every input. The\nOption\ntype provides a way of representing partial functions. An\nelement of\nOption β\nis either\nnone\nor of the form\nsome b\n,\nfor some value\nb : β\n. Thus we can think of an element\nf\nof the\ntype\nα → Option β\nas being a partial function from\nα\nto\nβ\n:\nfor every\na : α\n,\nf a\neither returns\nnone\n, indicating\nf a\nis "undefined", or\nsome b\n.\nAn element of\nInhabited α\nis simply a witness to the fact that\nthere is an element of\nα\n. Later, we will see that\nInhabited\nis\nan example of a\ntype class\nin Lean: Lean can be instructed that\nsuitable base types are inhabited, and can automatically infer that\nother constructed types are inhabited on that basis.\nAs exercises, we encourage you to develop a notion of composition for\npartial functions from\nα\nto\nβ\nand\nβ\nto\nγ\n, and show\nthat it behaves as expected. We also encourage you to show that\nBool\nand\nNat\nare inhabited, that the product of two inhabited\ntypes is inhabited, and that the type of functions to an inhabited\ntype is inhabited.\nInductively Defined Propositions\nInductively defined types can live in any type universe, including the\nbottom-most one,\nProp\n. In fact, this is exactly how the logical\nconnectives are defined.\nnamespace Hidden\ninductive False : Prop\n\ninductive True : Prop where\n  | intro : True\n\ninductive And (a b : Prop) : Prop where\n  | intro : a → b → And a b\n\ninductive Or (a b : Prop) : Prop where\n  | inl : a → Or a b\n  | inr : b → Or a b\nend Hidden\nYou should think about how these give rise to the introduction and\nelimination rules that you have already seen. There are rules that\ngovern what the eliminator of an inductive type can eliminate\nto\n,\nthat is, what kinds of types can be the target of a recursor. Roughly\nspeaking, what characterizes inductive types in\nProp\nis that one\ncan only eliminate to other types in\nProp\n. This is consistent with\nthe understanding that if\np : Prop\n, an element\nhp : p\ncarries\nno data. There is a small exception to this rule, however, which we\nwill discuss below, in\nSection Inductive Families\n.\nEven the existential quantifier is inductively defined:\nnamespace Hidden\ninductive Exists {α : Sort u} (p : α → Prop) : Prop where\n  | intro (w : α) (h : p w) : Exists p\nend Hidden\nKeep in mind that the notation\n∃ x : α, p\nis syntactic sugar for\nExists (fun x : α => p)\n.\nThe definitions of\nFalse\n,\nTrue\n,\nAnd\n, and\nOr\nare\nperfectly analogous to the definitions of\nEmpty\n,\nUnit\n,\nProd\n, and\nSum\n. The difference is that the first group yields\nelements of\nProp\n, and the second yields elements of\nType u\nfor\nsome\nu\n. In a similar way,\n∃ x : α, p\nis a\nProp\n-valued\nvariant of\nΣ x : α, p\n.\nThis is a good place to mention another inductive type, denoted\n{x : α // p}\n, which is sort of a hybrid between\n∃ x : α, P\nand\nΣ x : α, P\n.\nnamespace Hidden\ninductive Subtype {α : Type u} (p : α → Prop) where\n  | mk : (x : α) → p x → Subtype p\nend Hidden\nIn fact, in Lean,\nSubtype\nis defined using the structure command:\nnamespace Hidden\nstructure Subtype {α : Sort u} (p : α → Prop) where\n  val : α\n  property : p val\nend Hidden\nThe notation\n{x : α // p x}\nis syntactic sugar for\nSubtype (fun x : α => p x)\n.\nIt is modeled after subset notation in set theory: the idea is that\n{x : α // p x}\ndenotes the collection of elements of\nα\nthat have property\np\n.\nDefining the Natural Numbers\nThe inductively defined types we have seen so far are "flat":\nconstructors wrap data and insert it into a type, and the\ncorresponding recursor unpacks the data and acts on it. Things get\nmuch more interesting when the constructors act on elements of the\nvery type being defined. A canonical example is the type\nNat\nof\nnatural numbers:\nnamespace Hidden\ninductive Nat where\n  | zero : Nat\n  | succ : Nat → Nat\nend Hidden\nThere are two constructors. We start with\nzero : Nat\n; it takes\nno arguments, so we have it from the start. In contrast, the\nconstructor\nsucc\ncan only be applied to a previously constructed\nNat\n. Applying it to\nzero\nyields\nsucc zero : Nat\n. Applying\nit again yields\nsucc (succ zero) : Nat\n, and so on. Intuitively,\nNat\nis the "smallest" type with these constructors, meaning that\nit is exhaustively (and freely) generated by starting with\nzero\nand applying\nsucc\nrepeatedly.\nAs before, the recursor for\nNat\nis designed to define a dependent\nfunction\nf\nfrom\nNat\nto any domain, that is, an element\nf\nof\n(n : Nat) → motive n\nfor some\nmotive : Nat → Sort u\n.\nIt has to handle two cases: the case where the input is\nzero\n, and the case where\nthe input is of the form\nsucc n\nfor some\nn : Nat\n. In the first\ncase, we simply specify a target value with the appropriate type, as\nbefore. In the second case, however, the recursor can assume that a\nvalue of\nf\nat\nn\nhas already been computed. As a result, the\nnext argument to the recursor specifies a value for\nf (succ n)\nin\nterms of\nn\nand\nf n\n. If we check the type of the recursor,\nnamespace Hidden\ninductive Nat where\n| zero : Nat\n| succ : Nat → Nat\n#check @Nat.rec\nend Hidden\nyou find the following:\n{motive : Nat → Sort u}\n  → motive Nat.zero\n  → ((n : Nat) → motive n → motive (Nat.succ n))\n  → (t : Nat) → motive t\nThe implicit argument,\nmotive\n, is the codomain of the function being defined.\nIn type theory it is common to say\nmotive\nis the\nmotive\nfor the elimination/recursion,\nsince it describes the kind of object we wish to construct.\nThe next two arguments specify how to compute the zero and successor cases, as described above.\nThey are also known as the\nminor premises\n.\nFinally, the\nt : Nat\n, is the input to the function. It is also known as the\nmajor premise\n.\nThe\nNat.recOn\nis similar to\nNat.rec\nbut the major premise occurs before the minor premises.\n@Nat.recOn :\n  {motive : Nat → Sort u}\n  → (t : Nat)\n  → motive Nat.zero\n  → ((n : Nat) → motive n → motive (Nat.succ n))\n  → motive t\nConsider, for example, the addition function\nadd m n\non the\nnatural numbers. Fixing\nm\n, we can define addition by recursion on\nn\n. In the base case, we set\nadd m zero\nto\nm\n. In the\nsuccessor step, assuming the value\nadd m n\nis already determined,\nwe define\nadd m (succ n)\nto be\nsucc (add m n)\n.\nnamespace Hidden\ninductive Nat where\n  | zero : Nat\n  | succ : Nat → Nat\n  deriving Repr\n\ndef add (m n : Nat) : Nat :=\n  match n with\n  | Nat.zero   => m\n  | Nat.succ n => Nat.succ (add m n)\n\nopen Nat\n\n#eval add (succ (succ zero)) (succ zero)\nend Hidden\nIt is useful to put such definitions into a namespace,\nNat\n. We can\nthen go on to define familiar notation in that namespace. The two\ndefining equations for addition now hold definitionally:\nnamespace Hidden\ninductive Nat where\n| zero : Nat\n| succ : Nat → Nat\nderiving Repr\nnamespace Nat\n\ndef add (m n : Nat) : Nat :=\n  match n with\n  | Nat.zero   => m\n  | Nat.succ n => Nat.succ (add m n)\n\ninstance : Add Nat where\n  add := add\n\ntheorem add_zero (m : Nat) : m + zero = m := rfl\ntheorem add_succ (m n : Nat) : m + succ n = succ (m + n) := rfl\n\nend Nat\nend Hidden\nWe will explain how the\ninstance\ncommand works in\nChapter Type Classes\n. In the examples below, we will use\nLean\'s version of the natural numbers.\nProving a fact like\nzero + m = m\n, however, requires a proof by induction.\nAs observed above, the induction principle is just a special case of the recursion principle,\nwhen the codomain\nmotive n\nis an element of\nProp\n. It represents the familiar\npattern of an inductive proof: to prove\n∀ n, motive n\n, first prove\nmotive 0\n,\nand then, for arbitrary\nn\n, assume\nih : motive n\nand prove\nmotive (succ n)\n.\nnamespace Hidden\nopen Nat\n\ntheorem zero_add (n : Nat) : 0 + n = n :=\n  Nat.recOn (motive := fun x => 0 + x = x)\n   n\n   (show 0 + 0 = 0 from rfl)\n   (fun (n : Nat) (ih : 0 + n = n) =>\n    show 0 + succ n = succ n from\n    calc 0 + succ n\n      _ = succ (0 + n) := rfl\n      _ = succ n       := by rw [ih])\nend Hidden\nNotice that, once again, when\nNat.recOn\nis used in the context of\na proof, it is really the induction principle in disguise. The\nrewrite\nand\nsimp\ntactics tend to be very effective in proofs\nlike these. In this case, each can be used to reduce the proof to:\nnamespace Hidden\nopen Nat\n\ntheorem zero_add (n : Nat) : 0 + n = n :=\n  Nat.recOn (motive := fun x => 0 + x = x) n\n    rfl\n    (fun n ih => by simp [add_succ, ih])\nend Hidden\nAs another example, let us prove the associativity of addition,\n∀ m n k, m + n + k = m + (n + k)\n.\n(The notation\n+\n, as we have defined it, associates to the left, so\nm + n + k\nis really\n(m + n) + k\n.)\nThe hardest part is figuring out which variable to do the induction on. Since addition is defined by recursion on the second argument,\nk\nis a good guess, and once we make that choice the proof almost writes itself:\nnamespace Hidden\nopen Nat\ntheorem add_assoc (m n k : Nat) : m + n + k = m + (n + k) :=\n  Nat.recOn (motive := fun k => m + n + k = m + (n + k)) k\n    (show m + n + 0 = m + (n + 0) from rfl)\n    (fun k (ih : m + n + k = m + (n + k)) =>\n      show m + n + succ k = m + (n + succ k) from\n      calc m + n + succ k\n        _ = succ (m + n + k)   := rfl\n        _ = succ (m + (n + k)) := by rw [ih]\n        _ = m + succ (n + k)   := rfl\n        _ = m + (n + succ k)   := rfl)\nend Hidden\nOnce again, you can reduce the proof to:\nopen Nat\ntheorem add_assoc (m n k : Nat) : m + n + k = m + (n + k) :=\n  Nat.recOn (motive := fun k => m + n + k = m + (n + k)) k\n    rfl\n    (fun k ih => by simp [Nat.add_succ, ih])\nSuppose we try to prove the commutativity of addition. Choosing induction on the second argument, we might begin as follows:\nopen Nat\ntheorem add_comm (m n : Nat) : m + n = n + m :=\n  Nat.recOn (motive := fun x => m + x = x + m) n\n   (show m + 0 = 0 + m by rw [Nat.zero_add, Nat.add_zero])\n   (fun (n : Nat) (ih : m + n = n + m) =>\n    show m + succ n = succ n + m from\n    calc m + succ n\n      _ = succ (m + n) := rfl\n      _ = succ (n + m) := by rw [ih]\n      _ = succ n + m   := sorry)\nAt this point, we see that we need another supporting fact, namely, that\nsucc (n + m) = succ n + m\n.\nYou can prove this by induction on\nm\n:\nopen Nat\n\ntheorem succ_add (n m : Nat) : succ n + m = succ (n + m) :=\n  Nat.recOn (motive := fun x => succ n + x = succ (n + x)) m\n    (show succ n + 0 = succ (n + 0) from rfl)\n    (fun (m : Nat) (ih : succ n + m = succ (n + m)) =>\n     show succ n + succ m = succ (n + succ m) from\n     calc succ n + succ m\n       _ = succ (succ n + m)   := rfl\n       _ = succ (succ (n + m)) := by rw [ih]\n       _ = succ (n + succ m)   := rfl)\nYou can then replace the\nsorry\nin the previous proof with\nsucc_add\n. Yet again, the proofs can be compressed:\nnamespace Hidden\nopen Nat\ntheorem succ_add (n m : Nat) : succ n + m = succ (n + m) :=\n  Nat.recOn (motive := fun x => succ n + x = succ (n + x)) m\n    rfl\n    (fun m ih => by simp only [add_succ, ih])\n\ntheorem add_comm (m n : Nat) : m + n = n + m :=\n  Nat.recOn (motive := fun x => m + x = x + m) n\n    (by simp)\n    (fun m ih', 'model': 'text-embedding-3-small', 'encoding_format': 'base64'}}
2025-05-31 17:23:47,641 - DEBUG - Sending HTTP Request: POST https://api.openai.com/v1/embeddings
2025-05-31 17:23:47,641 - DEBUG - send_request_headers.started request=<Request [b'POST']>
2025-05-31 17:23:47,641 - DEBUG - send_request_headers.complete
2025-05-31 17:23:47,641 - DEBUG - send_request_body.started request=<Request [b'POST']>
2025-05-31 17:23:47,641 - DEBUG - send_request_body.complete
2025-05-31 17:23:47,641 - DEBUG - receive_response_headers.started request=<Request [b'POST']>
2025-05-31 17:23:48,173 - DEBUG - receive_response_headers.complete return_value=(b'HTTP/1.1', 429, b'Too Many Requests', [(b'Date', b'Sat, 31 May 2025 17:23:48 GMT'), (b'Content-Type', b'application/json; charset=utf-8'), (b'Content-Length', b'337'), (b'Connection', b'keep-alive'), (b'vary', b'Origin'), (b'x-request-id', b'req_f473e5c2a257e2da2c7074f8ccc4717f'), (b'strict-transport-security', b'max-age=31536000; includeSubDomains; preload'), (b'cf-cache-status', b'DYNAMIC'), (b'X-Content-Type-Options', b'nosniff'), (b'Server', b'cloudflare'), (b'CF-RAY', b'9488293ebe473b10-BOM'), (b'alt-svc', b'h3=":443"; ma=86400')])
2025-05-31 17:23:48,174 - INFO - HTTP Request: POST https://api.openai.com/v1/embeddings "HTTP/1.1 429 Too Many Requests"
2025-05-31 17:23:48,174 - DEBUG - receive_response_body.started request=<Request [b'POST']>
2025-05-31 17:23:48,174 - DEBUG - receive_response_body.complete
2025-05-31 17:23:48,174 - DEBUG - response_closed.started
2025-05-31 17:23:48,174 - DEBUG - response_closed.complete
2025-05-31 17:23:48,174 - DEBUG - HTTP Response: POST https://api.openai.com/v1/embeddings "429 Too Many Requests" Headers({'date': 'Sat, 31 May 2025 17:23:48 GMT', 'content-type': 'application/json; charset=utf-8', 'content-length': '337', 'connection': 'keep-alive', 'vary': 'Origin', 'x-request-id': 'req_f473e5c2a257e2da2c7074f8ccc4717f', 'strict-transport-security': 'max-age=31536000; includeSubDomains; preload', 'cf-cache-status': 'DYNAMIC', 'x-content-type-options': 'nosniff', 'server': 'cloudflare', 'cf-ray': '9488293ebe473b10-BOM', 'alt-svc': 'h3=":443"; ma=86400'})
2025-05-31 17:23:48,174 - DEBUG - request_id: req_f473e5c2a257e2da2c7074f8ccc4717f
2025-05-31 17:23:48,174 - DEBUG - Encountered httpx.HTTPStatusError
Traceback (most recent call last):
  File "/usr/local/lib/python3.12/dist-packages/openai/_base_client.py", line 1007, in _request
    response.raise_for_status()
  File "/usr/local/lib/python3.12/dist-packages/httpx/_models.py", line 829, in raise_for_status
    raise HTTPStatusError(message, request=request, response=self)
httpx.HTTPStatusError: Client error '429 Too Many Requests' for url 'https://api.openai.com/v1/embeddings'
For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/usr/local/lib/python3.12/dist-packages/openai/_base_client.py", line 1007, in _request
    response.raise_for_status()
  File "/usr/local/lib/python3.12/dist-packages/httpx/_models.py", line 829, in raise_for_status
    raise HTTPStatusError(message, request=request, response=self)
httpx.HTTPStatusError: Client error '429 Too Many Requests' for url 'https://api.openai.com/v1/embeddings'
For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/usr/local/lib/python3.12/dist-packages/openai/_base_client.py", line 1007, in _request
    response.raise_for_status()
  File "/usr/local/lib/python3.12/dist-packages/httpx/_models.py", line 829, in raise_for_status
    raise HTTPStatusError(message, request=request, response=self)
httpx.HTTPStatusError: Client error '429 Too Many Requests' for url 'https://api.openai.com/v1/embeddings'
For more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429
2025-05-31 17:23:48,175 - DEBUG - Re-raising status error
2025-05-31 17:23:48,496 - DEBUG - close.started
2025-05-31 17:23:48,497 - DEBUG - close.complete
